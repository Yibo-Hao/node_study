<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第九章-Node.js DBMS | node学习</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/node_study/assets/css/0.styles.d8fcd520.css" as="style"><link rel="preload" href="/node_study/assets/js/app.7ec7703d.js" as="script"><link rel="preload" href="/node_study/assets/js/2.0b30fde4.js" as="script"><link rel="preload" href="/node_study/assets/js/3.e87d396a.js" as="script"><link rel="prefetch" href="/node_study/assets/js/10.41c910e2.js"><link rel="prefetch" href="/node_study/assets/js/11.877f2538.js"><link rel="prefetch" href="/node_study/assets/js/12.1dea1fe9.js"><link rel="prefetch" href="/node_study/assets/js/13.03707fd2.js"><link rel="prefetch" href="/node_study/assets/js/14.74174926.js"><link rel="prefetch" href="/node_study/assets/js/15.240f734b.js"><link rel="prefetch" href="/node_study/assets/js/16.3d8565bd.js"><link rel="prefetch" href="/node_study/assets/js/17.7817c8e9.js"><link rel="prefetch" href="/node_study/assets/js/4.aa1c6637.js"><link rel="prefetch" href="/node_study/assets/js/5.dc83de53.js"><link rel="prefetch" href="/node_study/assets/js/6.42114519.js"><link rel="prefetch" href="/node_study/assets/js/7.5229d775.js"><link rel="prefetch" href="/node_study/assets/js/8.07f7fc74.js"><link rel="prefetch" href="/node_study/assets/js/9.de1235a9.js">
    <link rel="stylesheet" href="/node_study/assets/css/0.styles.d8fcd520.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/node_study/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/node_study/first/" class="sidebar-link">第一章-Node.js技术架构</a></li><li><a href="/node_study/second/" class="sidebar-link">第二章-Node.js文件模块（基础知识）</a></li><li><a href="/node_study/third/" class="sidebar-link">第二章-Node.js文件模块（Node.js）</a></li><li><a href="/node_study/four/" class="sidebar-link">第三章-package</a></li><li><a href="/node_study/fifth/" class="sidebar-link">第三章-Node.js命令行工具（命令行开发）</a></li><li><a href="/node_study/sixth/" class="sidebar-link">第四章-Node.js,jest 测试</a></li><li><a href="/node_study/seventh/" class="sidebar-link">第五章-Node.js,认识V8引擎（基础知识扩展）</a></li><li><a href="/node_study/eighth/" class="sidebar-link">第六章-Node.js,HTTP模块 + path 的两个API</a></li><li><a href="/node_study/ninth/" class="sidebar-link">第七章-Node.js 全局变量</a></li><li><a href="/node_study/tenth/" class="sidebar-link">第八章-Node.js 模块实现 + JS对象小知识点</a></li><li><a href="/node_study/eleventh/" aria-current="page" class="active sidebar-link">第九章-Node.js DBMS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node_study/eleventh/#dbms-的结构" class="sidebar-link">DBMS 的结构</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#数据库-1-0-文件系统" class="sidebar-link">数据库 1.0 —— 文件系统</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#数据库-2-0-规律存储" class="sidebar-link">数据库 2.0 —— 规律存储</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#数据库-3-0-简单操控" class="sidebar-link">数据库 3.0 —— 简单操控</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#数据库-4-0-隐藏技能" class="sidebar-link">数据库 4.0 —— 隐藏技能</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#mysql" class="sidebar-link">mysql</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#orm" class="sidebar-link">ORM</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#第一范式" class="sidebar-link">第一范式</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#第二范式" class="sidebar-link">第二范式</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#第三范式" class="sidebar-link">第三范式</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#设计数据库" class="sidebar-link">设计数据库</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#合并表" class="sidebar-link">合并表</a></li><li class="sidebar-sub-header"><a href="/node_study/eleventh/#事务" class="sidebar-link">事务</a></li></ul></li><li><a href="/node_study/twelve/" class="sidebar-link">第十章-Node.js 流</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第九章-node-js-dbms"><a href="#第九章-node-js-dbms" class="header-anchor">#</a> 第九章-Node.js DBMS</h1> <h2 id="dbms-的结构"><a href="#dbms-的结构" class="header-anchor">#</a> DBMS 的结构</h2> <p>数据库管理系统大致分为三块，数据库，数据管理者(服务端)，客户端。
<img src="/node_study/assets/img/download1.040e6571.png" alt="">
我们输入sql语句，server接受到命令，查找数据库，返回数据</p> <h2 id="数据库-1-0-文件系统"><a href="#数据库-1-0-文件系统" class="header-anchor">#</a> 数据库 1.0 —— 文件系统</h2> <p>下面我们就从数据库的发展历史来看什么是数据库。</p> <p>我们正在做一个电子书的小程序，一开始，我们把所有图书信息都放在 csv 文件中：</p> <div class="language- extra-class"><pre class="language-text"><code>Book.csv ( title , author , year )

&quot;Gone with the Wind&quot;,&quot;Margaret Mitchell&quot;,1936
&quot;Hamlet&quot;,&quot;William Shakespeare&quot;,1602
&quot;活着&quot;,&quot;余华&quot;,1993
&quot;三体&quot;,&quot;刘慈欣&quot;,2006
</code></pre></div><p>这种存储方式，实现起来简单，似乎很完美。</p> <p>接下来，我们要查询《三体》的作者，于是写了这段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>for line in file: 
record = parse(line)
    if &quot;三体&quot; == record[0]: 
        print record[1]
</code></pre></div><p>我们用了「遍历」，这是非常糟糕的查询方式。</p> <p>一旦后面数据量上去了，数据被存放在多个文件里，每次查询，我们就得打开很多个文件，打开后还要遍历里面的数据，「磁盘 IO」 和「时间复杂度」都很高。</p> <p>问题症结在于：我们的数据，是没有无规律的。</p> <p>一旦数据没有规律，我们查找数据时，就不知道数据在哪个文件，就只能一个个文件打开来看，靠蛮力去遍历。</p> <p>所以，让数据规律存储，是优化这个文件系统的第一步。</p> <h2 id="数据库-2-0-规律存储"><a href="#数据库-2-0-规律存储" class="header-anchor">#</a> 数据库 2.0 —— 规律存储</h2> <p>让数据有规律的存储，一旦数据有规律，我们就可以使用各种算法去高效地查找它们。</p> <p>让书籍，按照「字典排序」升序存储，于是我们可以进行「二分查找」，时间复杂度从 O(n) -&gt; O(log2n)，缺点是每次插入都要排序；</p> <p>让书籍，按照「Hash 表」的结构进行存储，于是我们可以进行「Hash 查找」，用空间换时间，时间复杂度 O(1)；</p> <p>让书籍，按照「二叉树」的结果进行存储，于是我们可以进行「二叉查找」，时间复杂度 O(log2n)；</p> <p>二叉树极端情况下会退化成 O(n)，于是有了「平衡二叉树」；</p> <p>平衡二叉树终究还是“二叉”，只有两个子节点，一次从磁盘 load 的数据太少，于是有了可以有多于 2 个子节点的 B 树；</p> <p>B 树找出来的数据，是无序的，如果你要求数据排好序返回，还要在内存手动排一次序，于是有了叶子节点是一个双向链表的 B+ 树；</p> <p>……</p> <p><strong>不断规律化你的存储结构，你就能得到越来越牛逼的查找性能。</strong></p> <p>当然你会发现，按照「作者」查询，我建一个 B+ 树，按照「年份」查询，我也建一个 B+ 树，这样每增加一个字段查询，我都要建一个 B+ 树，如果 B+ 树里面放的是全部数据的信息，那会很冗余、很占用空间；</p> <p>于是我让 B+ 树只记录数据的唯一标识，按照索引找打数据的唯一标识后，再去 load 全量的数据。</p> <p>这就是 Mysql 里面的「二级索引」和「聚簇索引」：</p> <p>「二级索引」只存储对应字段和唯一标识，查找时利用「二级索引」，可以快速找到数据的「唯一标识」；
「聚簇索引」是数据实际存储的位置，它也是有序的，按照「唯一标识」有序存储；
所以你在「二级索引」里拿到「唯一标识」后，可以快速地在「聚簇索引」找到数据的位置，大大减少了磁盘 IO；</p> <p>「索引」仅仅帮助你快速找到数据的标识，辅之以「数据规律的存储」，才能「减少磁盘 IO」,才能「加速查询」：</p> <p>索引 + 规律存储 = 快速查询</p> <h2 id="数据库-3-0-简单操控"><a href="#数据库-3-0-简单操控" class="header-anchor">#</a> 数据库 3.0 —— 简单操控</h2> <p>几乎你用过的所有数据库，都会提供让你很方便的操控它的方式。</p> <p>像 Mysql、Oracle 等关系型数据库，操作它们的语言，都是 SQL（Structured Query Language，结构化查询语言），这是结构化数据领域的通用语言，于是我们称之为 DSL（domain-specific language，领域特定语言）</p> <p>看似简简单单的语句背后，触发的可能是一连串复杂的逻辑。</p> <h2 id="数据库-4-0-隐藏技能"><a href="#数据库-4-0-隐藏技能" class="header-anchor">#</a> 数据库 4.0 —— 隐藏技能</h2> <p>缓存，集群，锁，事务</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>数据库，是你访问数据的中间件。通常我们在聊「数据库」时，聊得不只是个普通的数据，而是规律存储的数据，而且还有一个 DBMS，让我们去访问它。数据库，是你和数据打交道的媒介，你的所有对数据的操作，都会通过「数据库」来实现。</p> <h2 id="mysql"><a href="#mysql" class="header-anchor">#</a> mysql</h2> <p>永远不要手动更新或删除表，使用封装好的库来操作，减少不可逆的错误操作。</p> <h2 id="orm"><a href="#orm" class="header-anchor">#</a> ORM</h2> <p>面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能使用面向对象编程，来操作关系型数据库。</p> <p>数据库的表（table） --&gt; 类（class）</p> <p>记录（record，行数据）--&gt; 对象（object）</p> <p>字段（field）--&gt; 对象的属性（attribute）</p> <p>对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL，许多语言都有自己的 ORM 库。</p> <ol><li>使用 ORM 的第一步，就是你必须告诉它，怎么连接数据库</li> <li>连接数据库以后，下一步就要把数据库的表，转成一个类，叫做数据模型（Model）。</li> <li>数据库的基本操作有四种：create（新建）、read（读取）、update（更新）和delete（删除），简称 CRUD。ORM 将这四类操作，都变成了对象的方法。</li></ol> <h2 id="第一范式"><a href="#第一范式" class="header-anchor">#</a> 第一范式</h2> <p>第一范式：表中每一列的属性都不可再分.</p> <p>但是第一范式存在以下问题</p> <ol><li><p>数据冗余（比如学生编号、学生姓名、班级编号、院系等属性重复）</p></li> <li><p>插入数据异常 (比如新增一个名称为体育的院系,假如这个系没有学生，就不能插入）</p></li> <li><p>删除数据异常 (删除全部学生的信息, 院系也会被删除)</p></li> <li><p>修改数据异常 (假如存在学生转系的情况,修改会很繁琐)</p></li></ol> <h2 id="第二范式"><a href="#第二范式" class="header-anchor">#</a> 第二范式</h2> <p>第二范式：表中每一列的属性都不可再分，且非主属性完全依赖于主属性。</p> <p>在第一范式的基础上，要有键，所有字段完全依赖于键，键有多个字段，那么不允许部分依赖于该键。
<img src="/node_study/assets/img/download2.34f527e9.png" alt="">
上图中学号和课名是这个表的键，但是姓名部分依赖于学号，所有这个表不是第二范式
<img src="/node_study/assets/img/download3.52c7c594.png" alt="">
分成两个表，就变成了第二范式</p> <h2 id="第三范式"><a href="#第三范式" class="header-anchor">#</a> 第三范式</h2> <p>第三范式：表中每一列的属性都不可再分，且非主属性完全依赖于主属性，且每个非主属性都不传递函数依赖于主属性。这样数据插入和修改都很方便</p> <p>在2NF基础之上,消除非主属性对键的传递依赖,称为符合3NF</p> <p>不能有间接依赖，学号确定系名，系名确定系主任，所以系主任间接依赖于学号</p> <p><img src="/node_study/assets/img/download.fc6a2725.png" alt=""></p> <h2 id="设计数据库"><a href="#设计数据库" class="header-anchor">#</a> 设计数据库</h2> <p>高内聚：</p> <ul><li>如果两个字段能够单独建表，那就单独建</li> <li>把相关的放一起，不相关的分开建表</li></ul> <p>低耦合：</p> <ul><li>如果两个表有弱关系，那么可以加外键和中间表</li> <li>分为，一对一，一对多，多对多</li></ul> <h2 id="合并表"><a href="#合并表" class="header-anchor">#</a> 合并表</h2> <p>所谓&quot;连接&quot;，就是两张表根据关联字段，组合成一个数据集。问题是，两张表的关联字段的值往往是不一致的，如果关联字段不匹配，怎么处理？比如，表 A 包含张三和李四，表 B 包含李四和王五，匹配的只有李四这一条记录。</p> <p>在我们为了使用方便把表都拆开，有时候我们又需要重新合并表
<img src="/node_study/assets/img/bg2019011506.da52ae0d.jpg" alt=""></p> <h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <p><code>start transaction 语句1 语句2</code>一个语句失效那么全部不生效</p> <blockquote><p>https://ruanyifeng.com/blog/2019/01/table-join.html</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/node_study/tenth/" class="prev">
        第八章-Node.js 模块实现 + JS对象小知识点
      </a></span> <span class="next"><a href="/node_study/twelve/">
        第十章-Node.js 流
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/node_study/assets/js/app.7ec7703d.js" defer></script><script src="/node_study/assets/js/2.0b30fde4.js" defer></script><script src="/node_study/assets/js/3.e87d396a.js" defer></script>
  </body>
</html>
