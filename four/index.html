<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第三章-package | node学习</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/node_study/assets/css/0.styles.d8fcd520.css" as="style"><link rel="preload" href="/node_study/assets/js/app.7ec7703d.js" as="script"><link rel="preload" href="/node_study/assets/js/2.0b30fde4.js" as="script"><link rel="preload" href="/node_study/assets/js/12.1dea1fe9.js" as="script"><link rel="prefetch" href="/node_study/assets/js/10.41c910e2.js"><link rel="prefetch" href="/node_study/assets/js/11.877f2538.js"><link rel="prefetch" href="/node_study/assets/js/13.03707fd2.js"><link rel="prefetch" href="/node_study/assets/js/14.74174926.js"><link rel="prefetch" href="/node_study/assets/js/15.240f734b.js"><link rel="prefetch" href="/node_study/assets/js/16.3d8565bd.js"><link rel="prefetch" href="/node_study/assets/js/17.7817c8e9.js"><link rel="prefetch" href="/node_study/assets/js/3.e87d396a.js"><link rel="prefetch" href="/node_study/assets/js/4.aa1c6637.js"><link rel="prefetch" href="/node_study/assets/js/5.dc83de53.js"><link rel="prefetch" href="/node_study/assets/js/6.42114519.js"><link rel="prefetch" href="/node_study/assets/js/7.5229d775.js"><link rel="prefetch" href="/node_study/assets/js/8.07f7fc74.js"><link rel="prefetch" href="/node_study/assets/js/9.de1235a9.js">
    <link rel="stylesheet" href="/node_study/assets/css/0.styles.d8fcd520.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/node_study/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/node_study/first/" class="sidebar-link">第一章-Node.js技术架构</a></li><li><a href="/node_study/second/" class="sidebar-link">第二章-Node.js文件模块（基础知识）</a></li><li><a href="/node_study/third/" class="sidebar-link">第二章-Node.js文件模块（Node.js）</a></li><li><a href="/node_study/four/" aria-current="page" class="active sidebar-link">第三章-package</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node_study/four/#package-json" class="sidebar-link">package.json</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#name-字段" class="sidebar-link">name 字段</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#version-字段" class="sidebar-link">version 字段</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#描述信息（description-keywords）" class="sidebar-link">描述信息（description &amp; keywords）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#安装项目依赖（dependencies-devdependencies）" class="sidebar-link">安装项目依赖（dependencies &amp; devDependencies）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#简化终端命令（scripts）" class="sidebar-link">简化终端命令（scripts）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#定义项目入口（main）" class="sidebar-link">定义项目入口（main）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#发布文件配置（files）" class="sidebar-link">发布文件配置（files）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#定义私有模块（private）" class="sidebar-link">定义私有模块（private）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#指定模块适用系统（os）" class="sidebar-link">指定模块适用系统（os）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#自定义命令（bin）" class="sidebar-link">自定义命令（bin）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#设置应用根路径（homepage）" class="sidebar-link">设置应用根路径（homepage）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#bugs" class="sidebar-link">bugs</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#license" class="sidebar-link">license</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#根据开发环境采用不同的全局变量值（自定义字段）" class="sidebar-link">根据开发环境采用不同的全局变量值（自定义字段）</a></li><li class="sidebar-sub-header"><a href="/node_study/four/#webpack-配置不同状态" class="sidebar-link">webpack 配置不同状态</a></li></ul></li><li><a href="/node_study/fifth/" class="sidebar-link">第三章-Node.js命令行工具（命令行开发）</a></li><li><a href="/node_study/sixth/" class="sidebar-link">第四章-Node.js,jest 测试</a></li><li><a href="/node_study/seventh/" class="sidebar-link">第五章-Node.js,认识V8引擎（基础知识扩展）</a></li><li><a href="/node_study/eighth/" class="sidebar-link">第六章-Node.js,HTTP模块 + path 的两个API</a></li><li><a href="/node_study/ninth/" class="sidebar-link">第七章-Node.js 全局变量</a></li><li><a href="/node_study/tenth/" class="sidebar-link">第八章-Node.js 模块实现 + JS对象小知识点</a></li><li><a href="/node_study/eleventh/" class="sidebar-link">第九章-Node.js DBMS</a></li><li><a href="/node_study/twelve/" class="sidebar-link">第十章-Node.js 流</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第三章-package"><a href="#第三章-package" class="header-anchor">#</a> 第三章-package</h1> <h2 id="package-json"><a href="#package-json" class="header-anchor">#</a> package.json</h2> <p>在每个项目的根目录下面，一般都会有一个 package.json 文件，其定义了运行项目所需要的各种依赖和项目的配置信息（如名称、版本、许可证等元数据）。</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;name&quot;: &quot;my-test&quot;, # 项目名称
  &quot;version&quot;: &quot;1.0.0&quot;, # 项目版本（格式：大版本.次要版本.小版本）
  &quot;description&quot;: &quot;&quot;, # 项目描述
  &quot;main&quot;: &quot;index.js&quot;, # 入口文件
  &quot;scripts&quot;: { # 指定运行脚本命令的 npm 命令行缩写
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [], # 关键词
  &quot;author&quot;: &quot;&quot;, # 作者
  &quot;license&quot;: &quot;ISC&quot; # 许可证
}
</code></pre></div><p>package.json 中有非常多的配置项，其中必须填写的两个字段分别是 name 字段和 version 字段，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。</p> <h2 id="name-字段"><a href="#name-字段" class="header-anchor">#</a> name 字段</h2> <p>name 字段定义了模块的名称，name 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用，如果模块存在，可以查看该模块的一些基本信息，如果该模块名从未被使用过，则会抛出 404 错误，或者，我们也可以去 npm 上输入模块名，如果搜不到，则可以使用该模块名。</p> <p><code>npm view &lt;packageName&gt;</code></p> <ul><li><p>模块名会成为模块 url、命令行中的一个参数或者一个文件夹名称，任何非 url 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。</p></li> <li><p>若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 react-router-dom 已经存在，react.router.dom、reactrouterdom 都不可以再创建。</p></li> <li><p>name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。</p></li> <li><p>name不能以&quot;_&quot;或&quot;.&quot;开头</p></li> <li><p>不能含有大写字母</p></li> <li><p>name会成为url的一部分，不能含有url非法字符</p></li> <li><p>不要使用和node核心模块一样的名称</p></li> <li><p>name中不要含有&quot;js&quot;和&quot;node&quot;。</p></li></ul> <h2 id="version-字段"><a href="#version-字段" class="header-anchor">#</a> version 字段</h2> <p>npm 包中的模块版本都需要遵循 SemVer 规范，该规范的标准版本号采用 X.Y.Z 的格式，其中 X、Y 和 Z 均为非负的整数，且禁止在数字前方补零。</p> <ul><li>X 是主版本号(major)：修改了不兼容的 API</li> <li>Y 是次版本号(minor)：新增了向下兼容的功能</li> <li>Z 为修订号(patch)：修正了向下兼容的问题</li></ul> <p>当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，我们可能要先发布一个先行版本。
先行版本号可以加到主版本号.次版本号.修订号的后面，通过 - 号连接一连串以句点分隔的标识符和版本编译信息：</p> <ul><li>内部版本(alpha)</li> <li>公测版本(beta)</li> <li>正式版本的候选版本rc（即 Release candiate）</li></ul> <div class="language-shell script extra-class"><pre class="language-shell"><code><span class="token function">npm</span> view <span class="token operator">&lt;</span>packageName<span class="token operator">&gt;</span> version <span class="token comment"># 查看某个模块的最新版本</span>
<span class="token function">npm</span> view <span class="token operator">&lt;</span>packageName<span class="token operator">&gt;</span> versions <span class="token comment"># 查看某个模块的所有历史版本</span>
</code></pre></div><h2 id="描述信息（description-keywords）"><a href="#描述信息（description-keywords）" class="header-anchor">#</a> 描述信息（description &amp; keywords）</h2> <ul><li>description 字段用于添加模块的描述信息，便于用户了解该模块。</li> <li>keywords 字段用于给模块添加关键字。</li> <li>当我们使用 npm 检索模块时，会对模块中的 description 字段和 keywords 字段进行匹配，写好 package.json中的 description 和 keywords 将有利于增加我们模块的曝光率。</li></ul> <h2 id="安装项目依赖（dependencies-devdependencies）"><a href="#安装项目依赖（dependencies-devdependencies）" class="header-anchor">#</a> 安装项目依赖（dependencies &amp; devDependencies）</h2> <ul><li><p>dependencies字段指定了项目运行所依赖的模块（生产环境使用），如 antd、 react、 moment等插件库</p></li> <li><p>它们是我们生产环境所需要的依赖项，在把项目作为一个 npm 包的时候，用户安装 npm 包时只会安装 dependencies 里面的依赖。比如说项目文件中使用的import和require。</p></li> <li><p>devDependencies 字段指定了项目开发所需要的模块（开发环境使用），如 webpack、typescript、babel等：</p></li> <li><p>在代码打包提交线上时，我们并不需要这些工具，所以我们将它放入 devDependencies 中。</p></li> <li><p>如果一个模块不在 package.json 文件之中，我们可以单独安装这个模块，并使用相应的参数，将其写入 dependencies 字段/ devDependencies 字段中</p></li></ul> <div class="language-shell script extra-class"><pre class="language-shell"><code><span class="token comment"># 使用 npm</span>
<span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>package<span class="token punctuation">..</span>.<span class="token operator">&gt;</span> --save <span class="token comment"># 写入 dependencies 属性</span>
<span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>package<span class="token punctuation">..</span>.<span class="token operator">&gt;</span> --save-dev <span class="token comment"># 写入 devDependencies 属性</span>

<span class="token comment"># 使用 yarn</span>
<span class="token function">yarn</span> <span class="token function">add</span> <span class="token operator">&lt;</span>package<span class="token punctuation">..</span>.<span class="token operator">&gt;</span> <span class="token comment"># 写入 dependencies 属性</span>
<span class="token function">yarn</span> <span class="token function">add</span> <span class="token operator">&lt;</span>package<span class="token punctuation">..</span>.<span class="token operator">&gt;</span> --dev <span class="token comment"># 写入 devDependencies 属性</span>
</code></pre></div><p>有了 package.json 文件，开发直接使用 npm install / yarn install 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了</p> <h2 id="简化终端命令（scripts）"><a href="#简化终端命令（scripts）" class="header-anchor">#</a> 简化终端命令（scripts）</h2> <p>scripts 字段是 package.json 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 npm run 运行的脚本，值为实际运行的命令（通常是终端命令）</p> <h2 id="定义项目入口（main）"><a href="#定义项目入口（main）" class="header-anchor">#</a> 定义项目入口（main）</h2> <ul><li>main 字段是 package.json 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 npm 包，当用户安装你的包后，require('my-module') 返回的是 main 字段中所列出文件的 module.exports 属性。</li> <li>当不指定main 字段时，默认值是模块根目录下面的index.js 文件。</li></ul> <h2 id="发布文件配置（files）"><a href="#发布文件配置（files）" class="header-anchor">#</a> 发布文件配置（files）</h2> <p>files 字段用于描述我们使用 npm publish 命令后推送到 npm 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。另外，你也可以在模块根目录下创建一个&quot;.npmignore&quot;文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。</p> <p>写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法&quot;.gitignore&quot;类似。</p> <h2 id="定义私有模块（private）"><a href="#定义私有模块（private）" class="header-anchor">#</a> 定义私有模块（private）</h2> <p>一般公司的非开源项目，都会设置 private 属性的值为 true，这是因为 npm 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。</p> <h2 id="指定模块适用系统（os）"><a href="#指定模块适用系统（os）" class="header-anchor">#</a> 指定模块适用系统（os）</h2> <p>假如我们开发了一个模块，只能跑在 darwin 系统下，我们需要保证 windows 用户不会安装到该模块，从而避免发生不必要的错误。
这时候，使用 os 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会<strong>报错</strong>）</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ] # 适用系统
&quot;os&quot; : [ &quot;!win32&quot; ] # 黑名单
</code></pre></div><p>Tips：在 node 环境下可以使用 process.platform 来判断操作系统。</p> <p>指定项目 node 版本（engines）,engines属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。，指定模块适用 cpu 架构（cpu）也类似</p> <h2 id="自定义命令（bin）"><a href="#自定义命令（bin）" class="header-anchor">#</a> 自定义命令（bin）</h2> <ul><li>用过 vue-cli，create-react-app等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 vue create/create-react-app之类的命令，其实这和 package.json 中的 bin 字段有关。</li> <li>bin 字段用来指定各个内部命令对应的可执行文件的位置。当package.json 提供了 bin 字段后，即相当于做了一个命令名和本地文件名的映射。</li></ul> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;bin&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;my-app-cli&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./bin/cli.js&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码指定，my-app-cli 命令对应的可执行文件为 bin 子目录下的 cli.js，因此在安装了 my-app-cli 包的项目中，就可以很方便地利用 npm执行脚本：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  start<span class="token operator">:</span> 'node node_modules/.bin/my-app-cli'
<span class="token punctuation">}</span>
</code></pre></div><p>咦，怎么看起来和 vue create/create-react-app之类的命令不太像？原因：当需要 node 环境时就需要加上 node 前缀</p> <p>如果加上 node 前缀，就需要指定 my-app-cli 的路径 -&gt; node_modules/.bin，否则 node my-app-cli会去查找当前路径下的 my-app-cli.js，这样肯定是不对。（就是会把my-app-cli当做文件名，而不是命令）</p> <p>若要实现像 vue create/create-react-app之类的命令一样简便的方式，则可以在上文提到的 bin 子目录下可执行文件cli.js 中的第一行写入以下命令：</p> <p><code>#!/usr/bin/env node</code></p> <p>加了shebang我们就不用加 node ，加了 node 我们就不用加路径。</p> <p>这种方式只有发布到npm上然后下载下来，这个bin才会生效，单独在原项目里用是没有用的，如果你不想发布，可以修改~/.bashrc中的<code>alias fy=&quot;node +windows的绝对路径&quot;</code></p> <h2 id="设置应用根路径（homepage）"><a href="#设置应用根路径（homepage）" class="header-anchor">#</a> 设置应用根路径（homepage）</h2> <p>当我们使用 create-react-app 脚手架搭建的 React 项目，默认是使用内置的 webpack 配置，当package.json 中不配置 homepage 属性时，build 打包之后的文件资源应用路径默认是 /</p> <p>一般来说，我们打包的静态资源会部署在 CDN 上，为了让我们的应用知道去哪里加载资源，则需要我们设置一个根路径，这时可以通过 package.json 中的 homepage 字段设置应用的根路径。</p> <h2 id="bugs"><a href="#bugs" class="header-anchor">#</a> bugs</h2> <p>填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span> 
  <span class="token property">&quot;url&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;https://github.com/owner/project/issues&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;email&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;project@hostname.com&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="license"><a href="#license" class="header-anchor">#</a> license</h2> <p>你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。</p> <h2 id="根据开发环境采用不同的全局变量值（自定义字段）"><a href="#根据开发环境采用不同的全局变量值（自定义字段）" class="header-anchor">#</a> 根据开发环境采用不同的全局变量值（自定义字段）</h2> <p>假设有这么一个组件，当组件被点击时，在开发环境时是跳转测试环境的 sentry 地址，在正式环境时则跳转正式环境的 sentry 地址。</p> <p>首先，通过配置前面提到的 scripts 字段，实现环境变量（NODE_ENV）的设置：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
  &quot;start&quot;: &quot;NODE_ENV=development node scripts/start.js&quot;,
  &quot;build&quot;: &quot;NODE_ENV=production node scripts/build.js&quot;,
},
</code></pre></div><p>项目启动起来后，在代码中我们可以通过 process.env.NODE_ENV 访问到 NODE_ENV 的值。</p> <h2 id="webpack-配置不同状态"><a href="#webpack-配置不同状态" class="header-anchor">#</a> webpack 配置不同状态</h2> <p>我们可以在组件中写类似以下的判断代码，根据不同环境给 sentryUrl 设置不同的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> sentryUrl<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">'development'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sentryUrl <span class="token operator">=</span> <span class="token string">'test-sentry.xxx.com'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    sentryUrl <span class="token operator">=</span> <span class="token string">'sentry.xxx.com'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果有多个组件，要根据不同的环境使用不同的服务（多种服务）地址，如果按照上面的写法，项目中将存在许多重复的判断代码，且当服务地址发生变化时，包含这些服务地址的组件都需要相应的做改动，这样明显是不合理的。</p> <p>解决方案：相关服务的地址配置在 package.json中，同时修改项目的 webpack 配置，由webpack来判断不同的状态不同的打包方式。</p> <p>在项目根目录下使用 yarn eject 成功 eject 出配置后，可以发现项目目录的变化如下，如果需要定制化项目，一般就是在 config 目录下对默认的 webpack 配置进行修改，在这里我们需要关注 config/path.js 和 config/env.js 两个文件：</p> <p>env.js 的主要目的在于读取 env 配置文件并将 env 的配置信息给到全局变量 process.env ；</p> <p>path.js 的主要目的在于为项目提供各种路径，包括构建路径、 public 路径等。</p> <p>我们修改这两个文件来使，webpack来判断不同的状态不同的打包方式。</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;start&quot;</span><span class="token operator">:</span> <span class="token string">&quot;NODE_ENV=development node scripts/start.js&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;NODE_ENV=production node scripts/build.js&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token property">&quot;sentryPath&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://test-sentry.xxx.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;prod&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://sentry.xxx.com&quot;</span>
 <span class="token punctuation">}</span>

</code></pre></div><blockquote><p>https://juejin.im/post/5ebcd8b1e51d454dc20dd8a0
https://juejin.im/post/5d5e25b5f265da03970bbf82</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/node_study/third/" class="prev">
        第二章-Node.js文件模块（Node.js）
      </a></span> <span class="next"><a href="/node_study/fifth/">
        第三章-Node.js命令行工具（命令行开发）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/node_study/assets/js/app.7ec7703d.js" defer></script><script src="/node_study/assets/js/2.0b30fde4.js" defer></script><script src="/node_study/assets/js/12.1dea1fe9.js" defer></script>
  </body>
</html>
