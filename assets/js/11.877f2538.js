(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{363:function(e,t,a){"use strict";a.r(t);var s=a(42),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"第一章-node-js技术架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一章-node-js技术架构"}},[e._v("#")]),e._v(" 第一章-Node.js技术架构")]),e._v(" "),a("h2",{attrs:{id:"ajax的局部刷新和http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax的局部刷新和http"}},[e._v("#")]),e._v(" Ajax的局部刷新和HTTP")]),e._v(" "),a("p",[e._v("浏览器给网站发请求的过程一直没怎么变过。当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。")]),e._v(" "),a("p",[e._v("后来有了Ajax。有了Ajax，我们就不用每次都请求一个完整的新页面了，取而代之的是，每次只请求需要的部分页面信息就可以了。Ajax的诞生就是为了将全局刷新变为局部刷新。但是比如你要建一个FriendFeed这样的社交网站（类似人人网那样的刷朋友新鲜事的网站），你的好友会随时的推送新的状态，然后你的新鲜事会实时自动刷新。要达成这个需求，我们需要让用户一直与服务器保持一个有效连接。目前最简单的实现方法，就是让用户和服务器之间保持长轮询（long polling）。")]),e._v(" "),a("p",[e._v("HTTP请求不是持续的连接，你请求一次，服务器响应一次，然后就完了。长轮训是一种利用HTTP模拟持续连接的技巧。具体来说，只要页面载入了，不管你需不需要服务器给你响应信息，你都会给服务器发一个Ajax请求。这个请求不同于一般的Ajax请求，服务器不会直接给你返回信息，而是它要等着，直到服务器觉得该给你发信息了，它才会响应。比如等着你好友发新鲜事，等好友发完才给用户响应信息。")]),e._v(" "),a("p",[e._v("传统的服务器（比如Apache）。每次一个新用户连到你的网站上，你的服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的（比如等着你好友发新鲜事，等好友发完才给用户响应信息。或者等着数据库返回查询结果什么的）。虽然这些进程闲着，但是照样占用内存。这意味着，如果用户连接数的增长到一定规模，你服务器没准就要耗光内存直接瘫了。")]),e._v(" "),a("p",[e._v("解决方法就是：非阻塞和事件驱动。")]),e._v(" "),a("h2",{attrs:{id:"事件驱动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[e._v("#")]),e._v(" 事件驱动")]),e._v(" "),a("p",[e._v("所谓事件驱动，就是你点不同类型按钮，电脑执行不一样的操作。")]),e._v(" "),a("p",[e._v("第一种，网管过去一个一个问过来，需不需要续费，点餐，饮料之类的服务，但这样效率太低，费时费力。")]),e._v(" "),a("p",[e._v("所以他想到了第二种办法：让客户通过机子上的自助服务系统注明是要续费还是点餐或是饮料（事件收集器）并通过提交按钮（事件发送器）向网管发送请求，这样的话，网管只需要查看自主系统就可以清楚的知道用户的需求，并根据需求的不同分门别类的进行处理（这里网管作为事件处理器），从而大大的提高效率。")]),e._v(" "),a("p",[e._v("服务器只在用户那边有事件发生的时候才响应，这就是事件驱动。")]),e._v(" "),a("h2",{attrs:{id:"node-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js"}},[e._v("#")]),e._v(" Node.js")]),e._v(" "),a("p",[e._v("Node.js不是后端框架也不是一门编程语言。它是一个技术平台将多种技术组合起来，js本来是为了浏览器而诞生的语言，它让js也可以调用系统接口，开发后端应用，这也是它诞生的原因。")]),e._v(" "),a("ul",[a("li",[e._v("V8引擎-让我们用js开发的后端应用可以运行")]),e._v(" "),a("li",[e._v("libuv")]),e._v(" "),a("li",[e._v("c/c++实现的库")])]),e._v(" "),a("h2",{attrs:{id:"node-js的技术架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js的技术架构"}},[e._v("#")]),e._v(" Node.js的技术架构")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/15/16dcfa7f7433fb7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),e._v(" "),a("img",{attrs:{src:"https://github.com/yjhjstz/deep-into-node/raw/master/chapter1/a9e67142615f49863438cc0086b594e48984d1c9.jpeg",alt:""}})]),e._v(" "),a("ul",[a("li",[e._v("最上层的Node.js提供给我们每天都在用的标准库（http模块，fs模块，stream模块）我们可以通过js来直接调用这些API。")]),e._v(" "),a("li",[e._v("Node Bindings 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务。这一层是支撑 Node.js 运行的关键，由 C/C++ 实现")]),e._v(" "),a("li",[e._v("V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机。")]),e._v(" "),a("li",[e._v("Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力.")]),e._v(" "),a("li",[e._v("C-ares：提供了异步处理 DNS 相关的能力。")]),e._v(" "),a("li",[e._v("http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。")]),e._v(" "),a("li",[e._v("小结：node.js核心依赖的都是第三方c++的模块，通过 bindings 让js也可以调用这些c++库，继续封装暴露我们常用的顶层API。")])]),e._v(" "),a("h2",{attrs:{id:"libuv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#libuv"}},[e._v("#")]),e._v(" libuv")]),e._v(" "),a("p",[e._v("I/O：所有的输入输出都叫做I/O。写文件，读文件，打印文档，发送网络请求等，系统跟外界进行沟通都叫做I/O。")]),e._v(" "),a("p",[e._v("node.js使用了Google的V8解析引擎和Marc Lehmann的libev。Node.js将事件驱动的I/O模型与适合该模型的编程语言(Javascript)融合在了一起。随着node.js的日益流行，node.js需要同时支持windows, 但是libev只能在Unix环境下运行。Windows 平台上与kqueue(FreeBSD)或者(e)poll(Linux)等内核事件通知相应的机制是IOCP。")]),e._v(" "),a("p",[e._v("libuv提供了一个跨平台的抽象，由平台决定使用libev或IOCP。在node-v0.9.0版本中，libuv移除了libev的内容。")]),e._v(" "),a("p",[e._v("libuv所有功能都是异步的。")]),e._v(" "),a("h2",{attrs:{id:"v8引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎"}},[e._v("#")]),e._v(" V8引擎")]),e._v(" "),a("p",[e._v("V8引擎的主要功能")]),e._v(" "),a("ul",[a("li",[e._v("把JS源代码变成本地代码并执行")]),e._v(" "),a("li",[e._v("维护调用栈，确保JS函数的执行顺序")]),e._v(" "),a("li",[e._v("内存管理，为所有对象分配内存")]),e._v(" "),a("li",[e._v("垃圾回收，利用无用的内存")]),e._v(" "),a("li",[e._v("实现JS标准库")])]),e._v(" "),a("p",[e._v("V8本身是多线程的（例如垃圾回收占一个线程），但是执行JS时单线程执行的，V8不提供DOM API，V8可以开两个线程分别执行JS但是两个线程没有任何关系，V8自带事件循环，但是node.js根据libuv自己创建了一个事件循环。")]),e._v(" "),a("h3",{attrs:{id:"handle-句柄"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#handle-句柄"}},[e._v("#")]),e._v(" handle(句柄)")]),e._v(" "),a("p",[e._v("回忆之前学习JS原型链画过的内存图。")]),e._v(" "),a("p",[e._v("在 V8 中，内存分配都是在 V8 的 Heap 中进行分配的，JavaScript 的值和对象也都存放在 V8 的 Heap 中，变量放在 stack 中。这个 Heap 由 V8 独立的去维护，失去引用的对象将会被 V8 的 GC 掉并可以重新分配给其他对象。")]),e._v(" "),a("p",[e._v("V8 为了对内存分配进行管理，GC 需要对 V8 中的 所有对象进行跟踪，而对象都是用 Handle 方式引用的，所以 GC 需要对 Handle 进行管理，这样 GC 就能知道 Heap 中一个对象的引用情况，当一个对象的 Handle 引用发生改变的时候，GC 即可对该对象进行回收或者移动。因此，V8 编程中必须使用 Handle 去引用一个对象，而不是直接通过 C ++ 的方式去获取对象的引用，直接通过 C++ 的方式去引用一个对象，会使得该对象无法被 V8 管理。")]),e._v(" "),a("h3",{attrs:{id:"scope作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scope作用域"}},[e._v("#")]),e._v(" scope作用域")]),e._v(" "),a("p",[e._v("作用域可以看成是一个句柄的容器，在一个作用域里面可以有很多很多个句柄（也就是说，一个 scope 里面可以包含很多很多个 v8 引擎相关的对象），句柄指向的对象是可以一个一个单独地释放的，但是很多时候（真正开始写业务代码的时候），一个一个地释放句柄过于 繁琐，取而代之的是，可以释放一个 scope，那么包含在这个 scope 中的所有 handle 就都会被统一释放掉了。")]),e._v(" "),a("p",[e._v("HandleScope 是用来管理 Handle 的，而 Context::Scope 仅仅用来管理 Context 对象。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/yjhjstz/deep-into-node/raw/master/chapter2/Context.png",alt:""}})]),e._v(" "),a("p",[e._v("函数的开始部分都放一个 HandleScope，这样此函数中的 Handle 就不需要再理会释放资源了。直接释放函数 handler 即可。")]),e._v(" "),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("从概念上讲，这个上下文环境也可以理解为运行环境。在执行 javascript 脚本的时候，总要有一些环境变量或者全局函数。")]),e._v(" "),a("h2",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[e._v("#")]),e._v(" 事件循环")]),e._v(" "),a("p",[e._v("Event Loop就是对事件处理顺序的精确管理，因为异步事件有很多种，计时器，读文件，网络请求。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("┌───────────────────────┐\n┌─>│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │<──connections───     │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\n")])])]),a("p",[e._v("模型中的每一个方块代表事件循环的一个阶段。")]),e._v(" "),a("h3",{attrs:{id:"poll阶段-轮询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#poll阶段-轮询"}},[e._v("#")]),e._v(" poll阶段(轮询)")]),e._v(" "),a("p",[e._v("当v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下：先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入\n执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。")]),e._v(" "),a("p",[e._v("值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。")]),e._v(" "),a("p",[e._v("poll就是轮询不停地问操作系统，查看计时器")]),e._v(" "),a("h3",{attrs:{id:"check阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#check阶段"}},[e._v("#")]),e._v(" check阶段")]),e._v(" "),a("p",[e._v("check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。")]),e._v(" "),a("h3",{attrs:{id:"close阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#close阶段"}},[e._v("#")]),e._v(" close阶段")]),e._v(" "),a("p",[e._v("当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。")]),e._v(" "),a("h3",{attrs:{id:"timer阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#timer阶段"}},[e._v("#")]),e._v(" timer阶段")]),e._v(" "),a("p",[e._v("这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。")]),e._v(" "),a("h3",{attrs:{id:"i-o-callback阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o-callback阶段"}},[e._v("#")]),e._v(" I/O callback阶段")]),e._v(" "),a("p",[e._v("如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。")]),e._v(" "),a("h3",{attrs:{id:"settimeout-和setimmediate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-和setimmediate"}},[e._v("#")]),e._v(" setTimeout()和setImmediate()")]),e._v(" "),a("p",[e._v("连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("ul",[a("li",[e._v("用libuv进行异步I/O操作")]),e._v(" "),a("li",[e._v("用event loop管理事件处理顺序")]),e._v(" "),a("li",[e._v("用C/C++库高效处理DNS/HTTP.")]),e._v(" "),a("li",[e._v("用bindings让JS能和C/C++沟通（封装V8和libuv暴露基础API）")]),e._v(" "),a("li",[e._v("用V8运行JS")]),e._v(" "),a("li",[e._v("用Node.js标准库简化JS代码（用基础API封装顶层API）")])]),e._v(" "),a("p",[e._v("我们用js写的应用（用到了顶层API），经过V8引擎执行，如果事件是异步的V8会通过bindings传递给libuv，进入事件循环，最后再到V8执行代码。")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("更多细节👍："),a("a",{attrs:{href:"https://github.com/yjhjstz/deep-into-node",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/yjhjstz/deep-into-node"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);