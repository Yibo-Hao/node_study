(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{364:function(s,a,t){"use strict";t.r(a);var e=t(42),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"第三章-package"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三章-package"}},[s._v("#")]),s._v(" 第三章-package")]),s._v(" "),t("h2",{attrs:{id:"package-json"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#package-json"}},[s._v("#")]),s._v(" package.json")]),s._v(" "),t("p",[s._v("在每个项目的根目录下面，一般都会有一个 package.json 文件，其定义了运行项目所需要的各种依赖和项目的配置信息（如名称、版本、许可证等元数据）。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('{\n  "name": "my-test", # 项目名称\n  "version": "1.0.0", # 项目版本（格式：大版本.次要版本.小版本）\n  "description": "", # 项目描述\n  "main": "index.js", # 入口文件\n  "scripts": { # 指定运行脚本命令的 npm 命令行缩写\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "keywords": [], # 关键词\n  "author": "", # 作者\n  "license": "ISC" # 许可证\n}\n')])])]),t("p",[s._v("package.json 中有非常多的配置项，其中必须填写的两个字段分别是 name 字段和 version 字段，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。")]),s._v(" "),t("h2",{attrs:{id:"name-字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#name-字段"}},[s._v("#")]),s._v(" name 字段")]),s._v(" "),t("p",[s._v("name 字段定义了模块的名称，name 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用，如果模块存在，可以查看该模块的一些基本信息，如果该模块名从未被使用过，则会抛出 404 错误，或者，我们也可以去 npm 上输入模块名，如果搜不到，则可以使用该模块名。")]),s._v(" "),t("p",[t("code",[s._v("npm view <packageName>")])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("模块名会成为模块 url、命令行中的一个参数或者一个文件夹名称，任何非 url 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。")])]),s._v(" "),t("li",[t("p",[s._v("若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 react-router-dom 已经存在，react.router.dom、reactrouterdom 都不可以再创建。")])]),s._v(" "),t("li",[t("p",[s._v("name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。")])]),s._v(" "),t("li",[t("p",[s._v('name不能以"_"或"."开头')])]),s._v(" "),t("li",[t("p",[s._v("不能含有大写字母")])]),s._v(" "),t("li",[t("p",[s._v("name会成为url的一部分，不能含有url非法字符")])]),s._v(" "),t("li",[t("p",[s._v("不要使用和node核心模块一样的名称")])]),s._v(" "),t("li",[t("p",[s._v('name中不要含有"js"和"node"。')])])]),s._v(" "),t("h2",{attrs:{id:"version-字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#version-字段"}},[s._v("#")]),s._v(" version 字段")]),s._v(" "),t("p",[s._v("npm 包中的模块版本都需要遵循 SemVer 规范，该规范的标准版本号采用 X.Y.Z 的格式，其中 X、Y 和 Z 均为非负的整数，且禁止在数字前方补零。")]),s._v(" "),t("ul",[t("li",[s._v("X 是主版本号(major)：修改了不兼容的 API")]),s._v(" "),t("li",[s._v("Y 是次版本号(minor)：新增了向下兼容的功能")]),s._v(" "),t("li",[s._v("Z 为修订号(patch)：修正了向下兼容的问题")])]),s._v(" "),t("p",[s._v("当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，我们可能要先发布一个先行版本。\n先行版本号可以加到主版本号.次版本号.修订号的后面，通过 - 号连接一连串以句点分隔的标识符和版本编译信息：")]),s._v(" "),t("ul",[t("li",[s._v("内部版本(alpha)")]),s._v(" "),t("li",[s._v("公测版本(beta)")]),s._v(" "),t("li",[s._v("正式版本的候选版本rc（即 Release candiate）")])]),s._v(" "),t("div",{staticClass:"language-shell script extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" view "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("packageName"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" version "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看某个模块的最新版本")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" view "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("packageName"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" versions "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看某个模块的所有历史版本")]),s._v("\n")])])]),t("h2",{attrs:{id:"描述信息（description-keywords）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#描述信息（description-keywords）"}},[s._v("#")]),s._v(" 描述信息（description & keywords）")]),s._v(" "),t("ul",[t("li",[s._v("description 字段用于添加模块的描述信息，便于用户了解该模块。")]),s._v(" "),t("li",[s._v("keywords 字段用于给模块添加关键字。")]),s._v(" "),t("li",[s._v("当我们使用 npm 检索模块时，会对模块中的 description 字段和 keywords 字段进行匹配，写好 package.json中的 description 和 keywords 将有利于增加我们模块的曝光率。")])]),s._v(" "),t("h2",{attrs:{id:"安装项目依赖（dependencies-devdependencies）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装项目依赖（dependencies-devdependencies）"}},[s._v("#")]),s._v(" 安装项目依赖（dependencies & devDependencies）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("dependencies字段指定了项目运行所依赖的模块（生产环境使用），如 antd、 react、 moment等插件库")])]),s._v(" "),t("li",[t("p",[s._v("它们是我们生产环境所需要的依赖项，在把项目作为一个 npm 包的时候，用户安装 npm 包时只会安装 dependencies 里面的依赖。比如说项目文件中使用的import和require。")])]),s._v(" "),t("li",[t("p",[s._v("devDependencies 字段指定了项目开发所需要的模块（开发环境使用），如 webpack、typescript、babel等：")])]),s._v(" "),t("li",[t("p",[s._v("在代码打包提交线上时，我们并不需要这些工具，所以我们将它放入 devDependencies 中。")])]),s._v(" "),t("li",[t("p",[s._v("如果一个模块不在 package.json 文件之中，我们可以单独安装这个模块，并使用相应的参数，将其写入 dependencies 字段/ devDependencies 字段中")])])]),s._v(" "),t("div",{staticClass:"language-shell script extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 使用 npm")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("package"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" --save "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写入 dependencies 属性")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("package"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" --save-dev "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写入 devDependencies 属性")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 使用 yarn")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yarn")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("package"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写入 dependencies 属性")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yarn")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("package"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" --dev "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 写入 devDependencies 属性")]),s._v("\n")])])]),t("p",[s._v("有了 package.json 文件，开发直接使用 npm install / yarn install 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了")]),s._v(" "),t("h2",{attrs:{id:"简化终端命令（scripts）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简化终端命令（scripts）"}},[s._v("#")]),s._v(" 简化终端命令（scripts）")]),s._v(" "),t("p",[s._v("scripts 字段是 package.json 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 npm run 运行的脚本，值为实际运行的命令（通常是终端命令）")]),s._v(" "),t("h2",{attrs:{id:"定义项目入口（main）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义项目入口（main）"}},[s._v("#")]),s._v(" 定义项目入口（main）")]),s._v(" "),t("ul",[t("li",[s._v("main 字段是 package.json 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 npm 包，当用户安装你的包后，require('my-module') 返回的是 main 字段中所列出文件的 module.exports 属性。")]),s._v(" "),t("li",[s._v("当不指定main 字段时，默认值是模块根目录下面的index.js 文件。")])]),s._v(" "),t("h2",{attrs:{id:"发布文件配置（files）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布文件配置（files）"}},[s._v("#")]),s._v(" 发布文件配置（files）")]),s._v(" "),t("p",[s._v('files 字段用于描述我们使用 npm publish 命令后推送到 npm 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。另外，你也可以在模块根目录下创建一个".npmignore"文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。')]),s._v(" "),t("p",[s._v('写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。')]),s._v(" "),t("h2",{attrs:{id:"定义私有模块（private）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义私有模块（private）"}},[s._v("#")]),s._v(" 定义私有模块（private）")]),s._v(" "),t("p",[s._v("一般公司的非开源项目，都会设置 private 属性的值为 true，这是因为 npm 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。")]),s._v(" "),t("h2",{attrs:{id:"指定模块适用系统（os）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指定模块适用系统（os）"}},[s._v("#")]),s._v(" 指定模块适用系统（os）")]),s._v(" "),t("p",[s._v("假如我们开发了一个模块，只能跑在 darwin 系统下，我们需要保证 windows 用户不会安装到该模块，从而避免发生不必要的错误。\n这时候，使用 os 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会"),t("strong",[s._v("报错")]),s._v("）")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('"os" : [ "darwin", "linux" ] # 适用系统\n"os" : [ "!win32" ] # 黑名单\n')])])]),t("p",[s._v("Tips：在 node 环境下可以使用 process.platform 来判断操作系统。")]),s._v(" "),t("p",[s._v("指定项目 node 版本（engines）,engines属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。，指定模块适用 cpu 架构（cpu）也类似")]),s._v(" "),t("h2",{attrs:{id:"自定义命令（bin）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义命令（bin）"}},[s._v("#")]),s._v(" 自定义命令（bin）")]),s._v(" "),t("ul",[t("li",[s._v("用过 vue-cli，create-react-app等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 vue create/create-react-app之类的命令，其实这和 package.json 中的 bin 字段有关。")]),s._v(" "),t("li",[s._v("bin 字段用来指定各个内部命令对应的可执行文件的位置。当package.json 提供了 bin 字段后，即相当于做了一个命令名和本地文件名的映射。")])]),s._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"bin"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"my-app-cli"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"./bin/cli.js"')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("上面代码指定，my-app-cli 命令对应的可执行文件为 bin 子目录下的 cli.js，因此在安装了 my-app-cli 包的项目中，就可以很方便地利用 npm执行脚本：")]),s._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"scripts"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  start"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 'node node_modules/.bin/my-app-cli'\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("咦，怎么看起来和 vue create/create-react-app之类的命令不太像？原因：当需要 node 环境时就需要加上 node 前缀")]),s._v(" "),t("p",[s._v("如果加上 node 前缀，就需要指定 my-app-cli 的路径 -> node_modules/.bin，否则 node my-app-cli会去查找当前路径下的 my-app-cli.js，这样肯定是不对。（就是会把my-app-cli当做文件名，而不是命令）")]),s._v(" "),t("p",[s._v("若要实现像 vue create/create-react-app之类的命令一样简便的方式，则可以在上文提到的 bin 子目录下可执行文件cli.js 中的第一行写入以下命令：")]),s._v(" "),t("p",[t("code",[s._v("#!/usr/bin/env node")])]),s._v(" "),t("p",[s._v("加了shebang我们就不用加 node ，加了 node 我们就不用加路径。")]),s._v(" "),t("p",[s._v("这种方式只有发布到npm上然后下载下来，这个bin才会生效，单独在原项目里用是没有用的，如果你不想发布，可以修改~/.bashrc中的"),t("code",[s._v('alias fy="node +windows的绝对路径"')])]),s._v(" "),t("h2",{attrs:{id:"设置应用根路径（homepage）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置应用根路径（homepage）"}},[s._v("#")]),s._v(" 设置应用根路径（homepage）")]),s._v(" "),t("p",[s._v("当我们使用 create-react-app 脚手架搭建的 React 项目，默认是使用内置的 webpack 配置，当package.json 中不配置 homepage 属性时，build 打包之后的文件资源应用路径默认是 /")]),s._v(" "),t("p",[s._v("一般来说，我们打包的静态资源会部署在 CDN 上，为了让我们的应用知道去哪里加载资源，则需要我们设置一个根路径，这时可以通过 package.json 中的 homepage 字段设置应用的根路径。")]),s._v(" "),t("h2",{attrs:{id:"bugs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bugs"}},[s._v("#")]),s._v(" bugs")]),s._v(" "),t("p",[s._v("填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽")]),s._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" \n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"url"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"https://github.com/owner/project/issues"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"email"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"project@hostname.com"')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("h2",{attrs:{id:"license"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#license"}},[s._v("#")]),s._v(" license")]),s._v(" "),t("p",[s._v("你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。")]),s._v(" "),t("h2",{attrs:{id:"根据开发环境采用不同的全局变量值（自定义字段）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据开发环境采用不同的全局变量值（自定义字段）"}},[s._v("#")]),s._v(" 根据开发环境采用不同的全局变量值（自定义字段）")]),s._v(" "),t("p",[s._v("假设有这么一个组件，当组件被点击时，在开发环境时是跳转测试环境的 sentry 地址，在正式环境时则跳转正式环境的 sentry 地址。")]),s._v(" "),t("p",[s._v("首先，通过配置前面提到的 scripts 字段，实现环境变量（NODE_ENV）的设置：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('"scripts": {\n  "start": "NODE_ENV=development node scripts/start.js",\n  "build": "NODE_ENV=production node scripts/build.js",\n},\n')])])]),t("p",[s._v("项目启动起来后，在代码中我们可以通过 process.env.NODE_ENV 访问到 NODE_ENV 的值。")]),s._v(" "),t("h2",{attrs:{id:"webpack-配置不同状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-配置不同状态"}},[s._v("#")]),s._v(" webpack 配置不同状态")]),s._v(" "),t("p",[s._v("我们可以在组件中写类似以下的判断代码，根据不同环境给 sentryUrl 设置不同的值：")]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" sentryUrl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("process"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NODE_ENV")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("===")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'development'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    sentryUrl "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'test-sentry.xxx.com'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    sentryUrl "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'sentry.xxx.com'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("如果有多个组件，要根据不同的环境使用不同的服务（多种服务）地址，如果按照上面的写法，项目中将存在许多重复的判断代码，且当服务地址发生变化时，包含这些服务地址的组件都需要相应的做改动，这样明显是不合理的。")]),s._v(" "),t("p",[s._v("解决方案：相关服务的地址配置在 package.json中，同时修改项目的 webpack 配置，由webpack来判断不同的状态不同的打包方式。")]),s._v(" "),t("p",[s._v("在项目根目录下使用 yarn eject 成功 eject 出配置后，可以发现项目目录的变化如下，如果需要定制化项目，一般就是在 config 目录下对默认的 webpack 配置进行修改，在这里我们需要关注 config/path.js 和 config/env.js 两个文件：")]),s._v(" "),t("p",[s._v("env.js 的主要目的在于读取 env 配置文件并将 env 的配置信息给到全局变量 process.env ；")]),s._v(" "),t("p",[s._v("path.js 的主要目的在于为项目提供各种路径，包括构建路径、 public 路径等。")]),s._v(" "),t("p",[s._v("我们修改这两个文件来使，webpack来判断不同的状态不同的打包方式。")]),s._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"scripts"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"start"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"NODE_ENV=development node scripts/start.js"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"build"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"NODE_ENV=production node scripts/build.js"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"sentryPath"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"dev"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"https://test-sentry.xxx.com"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"prod"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"https://sentry.xxx.com"')]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n")])])]),t("blockquote",[t("p",[s._v("https://juejin.im/post/5ebcd8b1e51d454dc20dd8a0\nhttps://juejin.im/post/5d5e25b5f265da03970bbf82")])])])}),[],!1,null,null,null);a.default=n.exports}}]);