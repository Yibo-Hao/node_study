(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{361:function(a,s,e){"use strict";e.r(s);var v=e(42),t=Object(v.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"第二章-node-js文件模块（基础知识）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二章-node-js文件模块（基础知识）"}},[a._v("#")]),a._v(" 第二章-Node.js文件模块（基础知识）")]),a._v(" "),e("h2",{attrs:{id:"文件系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件系统"}},[a._v("#")]),a._v(" 文件系统")]),a._v(" "),e("p",[a._v("文件系统并不是由 js 或者 Node.js 实现的，而是由我们的操作系统，其中包含了如何分配存储，如何读取存储，如何实现文件系统和操作系统的协作交互。一句话总结一下文件系统其实就是：对磁盘设备的抽象，屏蔽了有关如何存储，操作等细节。")]),a._v(" "),e("p",[a._v("实际上，webpack 就是 node.js 对文件的操作。")]),a._v(" "),e("h2",{attrs:{id:"node-js的fs模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js的fs模块"}},[a._v("#")]),a._v(" Node.js的fs模块")]),a._v(" "),e("p",[a._v("实际上，大多数语言都已经实现了文件的读写，具体的做法就是添加抽象层，对于Node.js而言，我用以下简单的图示表示。")]),a._v(" "),e("p",[a._v("node提供了对V8和libuv的封装，所以我们在 node 中使用 js 时：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("|----|\n|node|\n|----|\n |\n |    读取js\n V\n|----|\n| V8 |\n|----|\n |\n |    c++调用lbuv\n V\n|------|\n|libUV |---\x3e调用系统API,读取文件\n|------|\n")])])]),e("p",[a._v("事件循环这个模型的最大缺点就是，一个实例，单线程，如果有任何阻塞发生（包括CPU计算卡顿）都会摧毁这个模型，所以，有且只有一个解：所有的IO都是，异步非阻塞IO。")]),a._v(" "),e("p",[a._v("线程池(Thread pool）模型，简单来说就是程序跑起来前，提前创建一个有多个线程的池子，IO消息来临时，塞进一个队列中，这些线程读取队列中的IO消息进行IO，IO完毕以后，通知主线程，触发回掉函数。")]),a._v(" "),e("p",[a._v("对于libuv来说，采用的就是线程池模型。（你没看错，虽然node.js是单线程的，但是也仅仅是主线程单线程，其底下是多线程的一个架构）。")]),a._v(" "),e("h2",{attrs:{id:"js如何通过，libuv如何读写文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js如何通过，libuv如何读写文件"}},[a._v("#")]),a._v(" js如何通过，libuv如何读写文件")]),a._v(" "),e("ol",[e("li",[a._v("node.js启动，包括底层的v8、libuv")]),a._v(" "),e("li",[a._v("用户写 js 代码调用 fs.read（）函数")]),a._v(" "),e("li",[a._v("fs.read（）之下，提交一个文件读取request（请求），立即返回，跑接下去的代码。")]),a._v(" "),e("li",[a._v("nodejs拿到这个request，传递给V8，v8解析以后，调用libuv的接口，塞入libuv的线程池队列")]),a._v(" "),e("li",[a._v("libuv的线程池队列拿到请求，选择一个线程，执行io操作，此时，读取io的线程卡住，但是整个系统依旧在跑")]),a._v(" "),e("li",[a._v("io 结束，执行 io 的线程将结果和完成标识符（done）")]),a._v(" "),e("li",[a._v("底层libuv调用 uv__fs_done 函数，这个是异步文件io结束后的回调函数。在uv__fs_done里面会回调上层C++模块的callback函数，这个callback函数就是我们用户指定的js层函数了。")])]),a._v(" "),e("ul",[e("li",[a._v("要实现js文件io，那必须要使得js能够调用系统API，也就是c++那层。这一层工作，由V8执行。")]),a._v(" "),e("li",[a._v("nodejs中，js文件io的事情，实际上是右libuv中的file/io来进行执行的。")])]),a._v(" "),e("h2",{attrs:{id:"事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[a._v("#")]),a._v(" 事件循环")]),a._v(" "),e("ol",[e("li",[a._v("事件循环本身就在libuv里。")]),a._v(" "),e("li",[a._v("在第六步io结束的时候，io线程设置了标识位，表示完成。然后线程归还线程库，等待继续调用。")]),a._v(" "),e("li",[a._v("libuv有一条线程是io观察者，这个io观察者会不断的检查这个标识位。当这个标识位为done的时候，io观察者就会触发回调。")]),a._v(" "),e("li",[a._v("io观察者将完成的事件放到自身的队列中，当成已经完成的对象，等待事件循环的处理")]),a._v(" "),e("li",[a._v("然后回调，上述整个过程叫做:event loop。")])]),a._v(" "),e("p",[a._v("这个回答了我的一个疑问，event loop既然是新的线程，怎么知道我的异步IO结束了。")]),a._v(" "),e("h2",{attrs:{id:"cache和buffer是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache和buffer是什么"}},[a._v("#")]),a._v(" Cache和Buffer是什么")]),a._v(" "),e("ul",[e("li",[a._v("Buffer的核心作用是用来缓冲，缓和冲击。比如你每秒要写100次硬盘，对系统冲击很大，浪费了大量时间在忙着处理开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲击就很小，写入效率高了，日子过得爽了。极大缓和了冲击。")]),a._v(" "),e("li",[a._v("Cache的核心作用是加快取用的速度。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个好拿的地方存着，下次不用再算了。加快了数据取用的速度。")]),a._v(" "),e("li",[a._v("所以，如果你注意关心过存储系统的话，你会发现硬盘的读写缓冲/缓存名称是不一样的，叫write-buffer和read-cache。很明显地说出了两者的区别。")]),a._v(" "),e("li",[a._v("宏观上说两者可能是混用的，你说拿cache做buffer用行不行？当然行，只要能控制cache淘汰逻辑就没有任何问题。那么拿buffer做cache用呢？貌似在很特殊的情况下，能确定访问顺序的时候，也是可以的。简单想一下就明白——buffer根据定义，需要随机存储吗？一般是不需要的。但cache一定要。所以大多数时候用cache代替buffer可以，反之就比较局限。这也是技术上说cache和buffer的关键区别。")]),a._v(" "),e("li",[a._v("补充1：不要误解Buffer就是用来写的，Cache就是用来读的。读可以用Buffer吗？当然可以，比如你想一批一批地处理读取而非有啥处理啥的时候，就可以用读buffer。写当然也可以用cache，比如你的写入有很高的随机性的时候。具体什么场景用Buffer什么场景用Cache要根据场景的具体需要决定。")]),a._v(" "),e("li",[a._v("补充2：不要误解Cache或Buffer就一定是内存或者存在什么高速媒介上的东西。只要相对高速即可。我完全可以在硬盘上存Cache，比如有些游戏会在运行时建立预编译的shader（暴露年龄），这本质上就是一种cache，它存在速度缓慢的硬盘上，因为读硬盘依旧比重新编译要快。Buffer也同理，例如NTFS文件系统自己就有Logging Buffer，这个甚至明确拒绝放在任何易失缓存里。")]),a._v(" "),e("li",[a._v("Cache和Buffer最大的区别在于，Buffer进多少数据就要出多少数据，Cache则进出不对称的，越不对称越好。")]),a._v(" "),e("li",[a._v("read-cache和write-buffer")])]),a._v(" "),e("h3",{attrs:{id:"随机存取和串行访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#随机存取和串行访问"}},[a._v("#")]),a._v(" 随机存取和串行访问")]),a._v(" "),e("p",[a._v("随机强调的是存取数据所花的时间与目标数据所在的物理位置无关。这是由RAM的结构决定的，RAM使用存储阵列来存储数据，只要给出行地址和列地址，就能确定目标数据，这一过程和目标数据所处的物理位置无关。")]),a._v(" "),e("p",[a._v("与随机存取相对的，是串行访问，指存取数据所花的时间与目标数据所在的物理位置有关。串行访问里面又分为顺序存取和直接存取。顺序存取如磁带，要想访问一个某一存储单元，必须先访问该单元前面的单元，（所以就有了听歌时倒磁带的痛苦经历）。直接存取如磁盘，磁头可以直接定位到目标存储单元，不需访问该单元前面的单元。需要注意的是，即使是直接定位，定位磁头所花的时间也是不同的，比如磁头当前在磁道0，定位到磁道2和磁道10000的时间肯定不同，所以存取数据所花的时间与目标数所在的物理位置仍然有关")]),a._v(" "),e("p",[a._v("解释了hash数据结构用空间换时间，以及cache必须要用随机存储")]),a._v(" "),e("h3",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),e("p",[a._v("cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到"),e("strong",[a._v("加快访问速度")]),a._v("的作用。")]),a._v(" "),e("p",[a._v("而 buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以"),e("strong",[a._v("减少响应次数")]),a._v("（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）")]),a._v(" "),e("h2",{attrs:{id:"权限位-mode"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#权限位-mode"}},[a._v("#")]),a._v(" 权限位 mode")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("drwxr-xr-x 1 koala 197121 0 Jun 28 14:41 core\n-rw-r--r-- 1 koala 197121 293 Jun 23 17:44 index.md\n")])])]),e("p",[a._v("第一位代表是文件还是文件夹，d 开头代表文件夹，- 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。")]),a._v(" "),e("p",[a._v("权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行")]),a._v(" "),e("h2",{attrs:{id:"文件系统标志-flag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件系统标志-flag"}},[a._v("#")]),a._v(" 文件系统标志 flag")]),a._v(" "),e("p",[a._v("'a': 打开文件用于追加。 如果文件不存在，则创建该文件。")]),a._v(" "),e("p",[a._v("'ax': 类似于 'a'，但如果路径存在，则失败。")]),a._v(" "),e("p",[a._v("'a+': 打开文件用于读取和追加。 如果文件不存在，则创建该文件。")]),a._v(" "),e("p",[a._v("'ax+': 类似于 'a+'，但如果路径存在，则失败。")]),a._v(" "),e("p",[a._v("'as': 打开文件用于追加（在同步模式中）。 如果文件不存在，则创建该文件。")]),a._v(" "),e("p",[a._v("'as+': 打开文件用于读取和追加（在同步模式中）。 如果文件不存在，则创建该文件。")]),a._v(" "),e("p",[a._v("'r': 打开文件用于读取。 如果文件不存在，则会发生异常。")]),a._v(" "),e("p",[a._v("'r+': 打开文件用于读取和写入。 如果文件不存在，则会发生异常。")]),a._v(" "),e("p",[a._v("'rs+': 打开文件用于读取和写入（在同步模式中）。 指示操作系统绕过本地的文件系统缓存。")]),a._v(" "),e("p",[a._v("这对于在 NFS 挂载上打开文件时非常有用，因为它可以跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此不建议使用此标志（除非真的需要）。")]),a._v(" "),e("p",[a._v("这不会把 fs.open() 或 fsPromises.open() 变成同步的阻塞调用。 如果需要同步的操作，则应使用 fs.openSync() 之类的。")]),a._v(" "),e("p",[a._v("'w': 打开文件用于写入。 如果文件不存在则创建文件，如果文件存在则截断文件。")]),a._v(" "),e("p",[a._v("'wx': 类似于 'w'，但如果路径存在，则失败。")]),a._v(" "),e("p",[a._v("'w+': 打开文件用于读取和写入。 如果文件不存在则创建文件，如果文件存在则截断文件。")]),a._v(" "),e("p",[a._v("'wx+': 类似于 'w+'，但如果路径存在，则失败。")]),a._v(" "),e("h2",{attrs:{id:"文件描述符-fs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件描述符-fs"}},[a._v("#")]),a._v(" 文件描述符 fs")]),a._v(" "),e("p",[a._v("操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。")]),a._v(" "),e("p",[a._v("在 Node.js 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。")]),a._v(" "),e("p",[a._v("node.js中文件描述符体会比较少，我们可以通过linux的几个基本的I/O操作函数来理解什么是文件操作符。文件描述符就是内核为了高效管理"),e("strong",[a._v("已被打开的文件")]),a._v("所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。")]),a._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[a._v("    fd "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("open")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("pathname"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" flags"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" mode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 返回了该文件的fd")]),a._v("\n    rlen "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("read")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("fd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" buf"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" count"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// IO操作均需要传入该文件的fd值")]),a._v("\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),e("p",[a._v("https://juejin.im/post/5d3f1664e51d4561a34618c1")])])])}),[],!1,null,null,null);s.default=t.exports}}]);