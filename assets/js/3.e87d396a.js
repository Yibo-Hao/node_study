(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{349:function(a,t,v){a.exports=v.p+"assets/img/download1.040e6571.png"},350:function(a,t,v){a.exports=v.p+"assets/img/download2.34f527e9.png"},351:function(a,t,v){a.exports=v.p+"assets/img/download3.52c7c594.png"},352:function(a,t,v){a.exports=v.p+"assets/img/download.fc6a2725.png"},353:function(a,t,v){a.exports=v.p+"assets/img/bg2019011506.da52ae0d.jpg"},365:function(a,t,v){"use strict";v.r(t);var _=v(42),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"第九章-node-js-dbms"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第九章-node-js-dbms"}},[a._v("#")]),a._v(" 第九章-Node.js DBMS")]),a._v(" "),_("h2",{attrs:{id:"dbms-的结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dbms-的结构"}},[a._v("#")]),a._v(" DBMS 的结构")]),a._v(" "),_("p",[a._v("数据库管理系统大致分为三块，数据库，数据管理者(服务端)，客户端。\n"),_("img",{attrs:{src:v(349),alt:""}}),a._v("\n我们输入sql语句，server接受到命令，查找数据库，返回数据")]),a._v(" "),_("h2",{attrs:{id:"数据库-1-0-文件系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-1-0-文件系统"}},[a._v("#")]),a._v(" 数据库 1.0 —— 文件系统")]),a._v(" "),_("p",[a._v("下面我们就从数据库的发展历史来看什么是数据库。")]),a._v(" "),_("p",[a._v("我们正在做一个电子书的小程序，一开始，我们把所有图书信息都放在 csv 文件中：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v('Book.csv ( title , author , year )\n\n"Gone with the Wind","Margaret Mitchell",1936\n"Hamlet","William Shakespeare",1602\n"活着","余华",1993\n"三体","刘慈欣",2006\n')])])]),_("p",[a._v("这种存储方式，实现起来简单，似乎很完美。")]),a._v(" "),_("p",[a._v("接下来，我们要查询《三体》的作者，于是写了这段代码：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v('for line in file: \nrecord = parse(line)\n    if "三体" == record[0]: \n        print record[1]\n')])])]),_("p",[a._v("我们用了「遍历」，这是非常糟糕的查询方式。")]),a._v(" "),_("p",[a._v("一旦后面数据量上去了，数据被存放在多个文件里，每次查询，我们就得打开很多个文件，打开后还要遍历里面的数据，「磁盘 IO」 和「时间复杂度」都很高。")]),a._v(" "),_("p",[a._v("问题症结在于：我们的数据，是没有无规律的。")]),a._v(" "),_("p",[a._v("一旦数据没有规律，我们查找数据时，就不知道数据在哪个文件，就只能一个个文件打开来看，靠蛮力去遍历。")]),a._v(" "),_("p",[a._v("所以，让数据规律存储，是优化这个文件系统的第一步。")]),a._v(" "),_("h2",{attrs:{id:"数据库-2-0-规律存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-2-0-规律存储"}},[a._v("#")]),a._v(" 数据库 2.0 —— 规律存储")]),a._v(" "),_("p",[a._v("让数据有规律的存储，一旦数据有规律，我们就可以使用各种算法去高效地查找它们。")]),a._v(" "),_("p",[a._v("让书籍，按照「字典排序」升序存储，于是我们可以进行「二分查找」，时间复杂度从 O(n) -> O(log2n)，缺点是每次插入都要排序；")]),a._v(" "),_("p",[a._v("让书籍，按照「Hash 表」的结构进行存储，于是我们可以进行「Hash 查找」，用空间换时间，时间复杂度 O(1)；")]),a._v(" "),_("p",[a._v("让书籍，按照「二叉树」的结果进行存储，于是我们可以进行「二叉查找」，时间复杂度 O(log2n)；")]),a._v(" "),_("p",[a._v("二叉树极端情况下会退化成 O(n)，于是有了「平衡二叉树」；")]),a._v(" "),_("p",[a._v("平衡二叉树终究还是“二叉”，只有两个子节点，一次从磁盘 load 的数据太少，于是有了可以有多于 2 个子节点的 B 树；")]),a._v(" "),_("p",[a._v("B 树找出来的数据，是无序的，如果你要求数据排好序返回，还要在内存手动排一次序，于是有了叶子节点是一个双向链表的 B+ 树；")]),a._v(" "),_("p",[a._v("……")]),a._v(" "),_("p",[_("strong",[a._v("不断规律化你的存储结构，你就能得到越来越牛逼的查找性能。")])]),a._v(" "),_("p",[a._v("当然你会发现，按照「作者」查询，我建一个 B+ 树，按照「年份」查询，我也建一个 B+ 树，这样每增加一个字段查询，我都要建一个 B+ 树，如果 B+ 树里面放的是全部数据的信息，那会很冗余、很占用空间；")]),a._v(" "),_("p",[a._v("于是我让 B+ 树只记录数据的唯一标识，按照索引找打数据的唯一标识后，再去 load 全量的数据。")]),a._v(" "),_("p",[a._v("这就是 Mysql 里面的「二级索引」和「聚簇索引」：")]),a._v(" "),_("p",[a._v("「二级索引」只存储对应字段和唯一标识，查找时利用「二级索引」，可以快速找到数据的「唯一标识」；\n「聚簇索引」是数据实际存储的位置，它也是有序的，按照「唯一标识」有序存储；\n所以你在「二级索引」里拿到「唯一标识」后，可以快速地在「聚簇索引」找到数据的位置，大大减少了磁盘 IO；")]),a._v(" "),_("p",[a._v("「索引」仅仅帮助你快速找到数据的标识，辅之以「数据规律的存储」，才能「减少磁盘 IO」,才能「加速查询」：")]),a._v(" "),_("p",[a._v("索引 + 规律存储 = 快速查询")]),a._v(" "),_("h2",{attrs:{id:"数据库-3-0-简单操控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-3-0-简单操控"}},[a._v("#")]),a._v(" 数据库 3.0 —— 简单操控")]),a._v(" "),_("p",[a._v("几乎你用过的所有数据库，都会提供让你很方便的操控它的方式。")]),a._v(" "),_("p",[a._v("像 Mysql、Oracle 等关系型数据库，操作它们的语言，都是 SQL（Structured Query Language，结构化查询语言），这是结构化数据领域的通用语言，于是我们称之为 DSL（domain-specific language，领域特定语言）")]),a._v(" "),_("p",[a._v("看似简简单单的语句背后，触发的可能是一连串复杂的逻辑。")]),a._v(" "),_("h2",{attrs:{id:"数据库-4-0-隐藏技能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-4-0-隐藏技能"}},[a._v("#")]),a._v(" 数据库 4.0 —— 隐藏技能")]),a._v(" "),_("p",[a._v("缓存，集群，锁，事务")]),a._v(" "),_("h2",{attrs:{id:"小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),_("p",[a._v("数据库，是你访问数据的中间件。通常我们在聊「数据库」时，聊得不只是个普通的数据，而是规律存储的数据，而且还有一个 DBMS，让我们去访问它。数据库，是你和数据打交道的媒介，你的所有对数据的操作，都会通过「数据库」来实现。")]),a._v(" "),_("h2",{attrs:{id:"mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[a._v("#")]),a._v(" mysql")]),a._v(" "),_("p",[a._v("永远不要手动更新或删除表，使用封装好的库来操作，减少不可逆的错误操作。")]),a._v(" "),_("h2",{attrs:{id:"orm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#orm"}},[a._v("#")]),a._v(" ORM")]),a._v(" "),_("p",[a._v("面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能使用面向对象编程，来操作关系型数据库。")]),a._v(" "),_("p",[a._v("数据库的表（table） --\x3e 类（class）")]),a._v(" "),_("p",[a._v("记录（record，行数据）--\x3e 对象（object）")]),a._v(" "),_("p",[a._v("字段（field）--\x3e 对象的属性（attribute）")]),a._v(" "),_("p",[a._v("对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL，许多语言都有自己的 ORM 库。")]),a._v(" "),_("ol",[_("li",[a._v("使用 ORM 的第一步，就是你必须告诉它，怎么连接数据库")]),a._v(" "),_("li",[a._v("连接数据库以后，下一步就要把数据库的表，转成一个类，叫做数据模型（Model）。")]),a._v(" "),_("li",[a._v("数据库的基本操作有四种：create（新建）、read（读取）、update（更新）和delete（删除），简称 CRUD。ORM 将这四类操作，都变成了对象的方法。")])]),a._v(" "),_("h2",{attrs:{id:"第一范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一范式"}},[a._v("#")]),a._v(" 第一范式")]),a._v(" "),_("p",[a._v("第一范式：表中每一列的属性都不可再分.")]),a._v(" "),_("p",[a._v("但是第一范式存在以下问题")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("数据冗余（比如学生编号、学生姓名、班级编号、院系等属性重复）")])]),a._v(" "),_("li",[_("p",[a._v("插入数据异常 (比如新增一个名称为体育的院系,假如这个系没有学生，就不能插入）")])]),a._v(" "),_("li",[_("p",[a._v("删除数据异常 (删除全部学生的信息, 院系也会被删除)")])]),a._v(" "),_("li",[_("p",[a._v("修改数据异常 (假如存在学生转系的情况,修改会很繁琐)")])])]),a._v(" "),_("h2",{attrs:{id:"第二范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二范式"}},[a._v("#")]),a._v(" 第二范式")]),a._v(" "),_("p",[a._v("第二范式：表中每一列的属性都不可再分，且非主属性完全依赖于主属性。")]),a._v(" "),_("p",[a._v("在第一范式的基础上，要有键，所有字段完全依赖于键，键有多个字段，那么不允许部分依赖于该键。\n"),_("img",{attrs:{src:v(350),alt:""}}),a._v("\n上图中学号和课名是这个表的键，但是姓名部分依赖于学号，所有这个表不是第二范式\n"),_("img",{attrs:{src:v(351),alt:""}}),a._v("\n分成两个表，就变成了第二范式")]),a._v(" "),_("h2",{attrs:{id:"第三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三范式"}},[a._v("#")]),a._v(" 第三范式")]),a._v(" "),_("p",[a._v("第三范式：表中每一列的属性都不可再分，且非主属性完全依赖于主属性，且每个非主属性都不传递函数依赖于主属性。这样数据插入和修改都很方便")]),a._v(" "),_("p",[a._v("在2NF基础之上,消除非主属性对键的传递依赖,称为符合3NF")]),a._v(" "),_("p",[a._v("不能有间接依赖，学号确定系名，系名确定系主任，所以系主任间接依赖于学号")]),a._v(" "),_("p",[_("img",{attrs:{src:v(352),alt:""}})]),a._v(" "),_("h2",{attrs:{id:"设计数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计数据库"}},[a._v("#")]),a._v(" 设计数据库")]),a._v(" "),_("p",[a._v("高内聚：")]),a._v(" "),_("ul",[_("li",[a._v("如果两个字段能够单独建表，那就单独建")]),a._v(" "),_("li",[a._v("把相关的放一起，不相关的分开建表")])]),a._v(" "),_("p",[a._v("低耦合：")]),a._v(" "),_("ul",[_("li",[a._v("如果两个表有弱关系，那么可以加外键和中间表")]),a._v(" "),_("li",[a._v("分为，一对一，一对多，多对多")])]),a._v(" "),_("h2",{attrs:{id:"合并表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合并表"}},[a._v("#")]),a._v(" 合并表")]),a._v(" "),_("p",[a._v('所谓"连接"，就是两张表根据关联字段，组合成一个数据集。问题是，两张表的关联字段的值往往是不一致的，如果关联字段不匹配，怎么处理？比如，表 A 包含张三和李四，表 B 包含李四和王五，匹配的只有李四这一条记录。')]),a._v(" "),_("p",[a._v("在我们为了使用方便把表都拆开，有时候我们又需要重新合并表\n"),_("img",{attrs:{src:v(353),alt:""}})]),a._v(" "),_("h2",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),_("p",[_("code",[a._v("start transaction 语句1 语句2")]),a._v("一个语句失效那么全部不生效")]),a._v(" "),_("blockquote",[_("p",[a._v("https://ruanyifeng.com/blog/2019/01/table-join.html")])])])}),[],!1,null,null,null);t.default=s.exports}}]);