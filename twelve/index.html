<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第十章-Node.js 流 | node学习</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/node_study/assets/css/0.styles.d8fcd520.css" as="style"><link rel="preload" href="/node_study/assets/js/app.7ec7703d.js" as="script"><link rel="preload" href="/node_study/assets/js/2.0b30fde4.js" as="script"><link rel="preload" href="/node_study/assets/js/6.42114519.js" as="script"><link rel="prefetch" href="/node_study/assets/js/10.41c910e2.js"><link rel="prefetch" href="/node_study/assets/js/11.877f2538.js"><link rel="prefetch" href="/node_study/assets/js/12.1dea1fe9.js"><link rel="prefetch" href="/node_study/assets/js/13.03707fd2.js"><link rel="prefetch" href="/node_study/assets/js/14.74174926.js"><link rel="prefetch" href="/node_study/assets/js/15.240f734b.js"><link rel="prefetch" href="/node_study/assets/js/16.3d8565bd.js"><link rel="prefetch" href="/node_study/assets/js/17.7817c8e9.js"><link rel="prefetch" href="/node_study/assets/js/3.e87d396a.js"><link rel="prefetch" href="/node_study/assets/js/4.aa1c6637.js"><link rel="prefetch" href="/node_study/assets/js/5.dc83de53.js"><link rel="prefetch" href="/node_study/assets/js/7.5229d775.js"><link rel="prefetch" href="/node_study/assets/js/8.07f7fc74.js"><link rel="prefetch" href="/node_study/assets/js/9.de1235a9.js">
    <link rel="stylesheet" href="/node_study/assets/css/0.styles.d8fcd520.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/node_study/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/node_study/first/" class="sidebar-link">第一章-Node.js技术架构</a></li><li><a href="/node_study/second/" class="sidebar-link">第二章-Node.js文件模块（基础知识）</a></li><li><a href="/node_study/third/" class="sidebar-link">第二章-Node.js文件模块（Node.js）</a></li><li><a href="/node_study/four/" class="sidebar-link">第三章-package</a></li><li><a href="/node_study/fifth/" class="sidebar-link">第三章-Node.js命令行工具（命令行开发）</a></li><li><a href="/node_study/sixth/" class="sidebar-link">第四章-Node.js,jest 测试</a></li><li><a href="/node_study/seventh/" class="sidebar-link">第五章-Node.js,认识V8引擎（基础知识扩展）</a></li><li><a href="/node_study/eighth/" class="sidebar-link">第六章-Node.js,HTTP模块 + path 的两个API</a></li><li><a href="/node_study/ninth/" class="sidebar-link">第七章-Node.js 全局变量</a></li><li><a href="/node_study/tenth/" class="sidebar-link">第八章-Node.js 模块实现 + JS对象小知识点</a></li><li><a href="/node_study/eleventh/" class="sidebar-link">第九章-Node.js DBMS</a></li><li><a href="/node_study/twelve/" aria-current="page" class="active sidebar-link">第十章-Node.js 流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node_study/twelve/#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#管道" class="sidebar-link">管道</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#为什么使用流？" class="sidebar-link">为什么使用流？</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#stream-的原型" class="sidebar-link">Stream 的原型</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#事件" class="sidebar-link">事件</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#可读流" class="sidebar-link">可读流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#可写流" class="sidebar-link">可写流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#创建自己的可写流" class="sidebar-link">创建自己的可写流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#创建自己的可读流" class="sidebar-link">创建自己的可读流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#可读流的两种状态" class="sidebar-link">可读流的两种状态</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#read-size" class="sidebar-link">read(size)</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#数据会不会漏掉" class="sidebar-link">数据会不会漏掉</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#关于-push-的数据大小" class="sidebar-link">关于 push 的数据大小</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#可写流工作流程" class="sidebar-link">可写流工作流程</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#双工流" class="sidebar-link">双工流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#转换流" class="sidebar-link">转换流</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#webpack" class="sidebar-link">webpack</a></li><li class="sidebar-sub-header"><a href="/node_study/twelve/#缓冲" class="sidebar-link">缓冲</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第十章-node-js-流"><a href="#第十章-node-js-流" class="header-anchor">#</a> 第十章-Node.js 流</h1> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&quot;./big_file.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
stream<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从程序角度而言流是有方向的数据，stream 是水流但是默认没有水，stream.write 可以让水流中有水（数据），每次写的小数据叫 chunk （块），产生数据的一段叫 source ，得到数据的一段叫 sink 。</p> <p><img src="/node_study/assets/img/download1.2dc94396.png" alt=""></p> <p>createWriteStream，开启了一条管道</p> <h2 id="管道"><a href="#管道" class="header-anchor">#</a> 管道</h2> <p>两个流可以用一个管道相连，stream1 的末尾连接上 stream2 的开端，只要 stream1 有数据，就会流到 stream2</p> <p><code>stream1.pipe(stream2)</code></p> <p>等价于</p> <div class="language-js extra-class"><pre class="language-js"><code>stream1<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token parameter">chunk</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  stream2<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stream1<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  stream2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就实现了不同流的转化</p> <ul><li>主动监听源可读流的data事件，在该事件的监听函数中，向目标可写流写入数据。</li> <li>若目标可写流表示该写入操作需要进行缓冲，则立刻将源可读流切换至暂停模式。</li> <li>监听目标可写流的drain事件，当目标可写流里所有需要缓冲的写入操作都完毕后，将流重新切换回流动模式。</li> <li>监听源可读流的end事件，相应地结束目标可写流。</li> <li>我们很少使用drain，因为pipe替我们使用了drain事件</li></ul> <p>readable.pipe() 会返回目标流的引用</p> <h2 id="为什么使用流？"><a href="#为什么使用流？" class="header-anchor">#</a> 为什么使用流？</h2> <p>一般我们处理数据有两种模式：buffer 模式、stream 模式</p> <ul><li>buffer 模式：取完数据一次性操作</li> <li>stream 模式：边取数据边操作</li></ul> <p>你想用手机看部电影，用 buffer 模式就是你把这个电影全部缓存下来，然后再看。用 stream 模式，就是你边缓存边看</p> <p>所以从这里就可以看出 stream 模式无论是在空间和时间上都优于 buffer 模式:</p> <p>空间上：内存只会占用当前需要处理的一块数据区域的大小, 而不是整个文件
时间上：因为不需要全部的数据就可以开始处理, 所以时间就相当于是节约了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&quot;data.txt&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果指定了 data，则相当于调用 response.write(data, encoding) 之后再调用 response.end(callback)。</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的这段代码并没有什么问题，但是在每次请求时，我们都会把整个 data.txt 文件读入到内存中，然后再把结果返回给客户端。想想看，如果 data.txt 文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。</p> <p>其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。</p> <p>所幸的是，(req,res)参数都是流对象，这意味着我们可以使用一种更好的方法来实现上面的需求：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&quot;/data.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="stream-的原型"><a href="#stream-的原型" class="header-anchor">#</a> Stream 的原型</h2> <p>自身的属性，由 fs.ReadStream 构造函数构造的
原型: stream.Readable.prototype
二级原型: stream.Stream.prototype
三级原型: events.EventEmitter.prototype 这是所有 Stream 都继承的原型
四级原型: Object.prototype 也就是所有对象都继承的原型</p> <h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <ul><li>Readable Stream：data,end,error,close,readable</li> <li>文件未读完被关闭了（close），文件被占用变为可读时（readable）</li> <li>Writable Stream：drain,finish(整个写完),error,close,pipe,unpipe</li> <li>drain：当一个可写流一下接受了太多的数据，导致管道阻塞不能及时写入，那么应该停止读取数据。当阻塞的数据都被读完时，触发&quot;drain&quot;事件</li></ul> <h2 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h2> <ul><li>Readable Stream：pipe,unpipe,wrap,destroy,read,unshift,resume,pause,isPaused,setEncoding</li> <li>Writable Stream：write,destroy,end,cork,uncork,setDefaultEncoding</li></ul> <h2 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h2> <p>nodejs 底层一共提供了 4 个流， Readable 流、Writable 流、Duplex 流和 Transform 流。</p> <p>Transform 是自己写自己读,babel，把 es6 转换为，我们在左边写入 es6，从右边读取 es5。 就像洗车一样，黑车进去，白车出来。</p> <h2 id="可读流"><a href="#可读流" class="header-anchor">#</a> 可读流</h2> <ul><li>可读流是可以停止的，静止态 paused 和流动态 flowing</li> <li>可读流默认处于 paused 态。</li> <li>一旦添加 data 事件监听，它就变为 flowing 态。</li> <li>删掉 data 事件监听，paused 态。</li> <li>pause() 可以将它变为 paused。</li> <li>resume() 可以将它变为 flowing。</li> <li>pipe() 本质上监视了 data 事件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 默认处于 paused 态</span>
  <span class="token keyword">const</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">&quot;./big_file.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 暂停</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 恢复</span>
    stream<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="可写流"><a href="#可写流" class="header-anchor">#</a> 可写流</h2> <p>drain 表示可以加点水了，也就是可以继续写入数据了。 我们调用 stream.write(chunk) 的时候，可能会得到 false。</p> <p>false 的意思是你写太快了，积压数据。</p> <p>这个时候我们就不能再 write 了，要监听 drain。</p> <p>等 drain 事件触发了，我们才能继续 write。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将 data 写入文件 1000000 次</span>
<span class="token keyword">function</span> <span class="token function">writeOneMillionTimes</span><span class="token punctuation">(</span><span class="token parameter">writer<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ok <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      i<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 最后一次写入</span>
        writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在这里判断是不是可以继续写</span>
        <span class="token comment">// ok 为 false 的意思是你写太快了，数据积压</span>
        ok <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ok <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;不能再写了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ok<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 干涸了,可以继续写入</span>
      writer<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">&quot;drain&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;干涸了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> writer <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&quot;./../big_file.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">writeOneMillionTimes</span><span class="token punctuation">(</span>writer<span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在调用 stream.end() 之后，而且缓冲区数据都已经传给底层系统之后，触发 finish 事件。</p> <p>我们往文件中写入数据时，不是直接存入硬盘中，而是先放入缓冲区。 当数据到达一定大小后，才会写入硬盘。</p> <h2 id="创建自己的可写流"><a href="#创建自己的可写流" class="header-anchor">#</a> 创建自己的可写流</h2> <p>我们一直都在使用其他模块的流，比如文件模块的可读流，http 模块的可写流，继承自基类后还封装了各自的 API</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Writable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> outStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Writable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 如果别人调用，我们做什么</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进入下一个流程</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>outStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以发现不同模块提供的流， write 实现的差异导致它们的特性不同，比如 http 模块的可写流，如果 res.end() 指定了 data，则相当于调用 response.write(data, encoding) 之后再调用 response.end(callback)。本质上响应就是调用流的 write 函数。</p> <h2 id="创建自己的可读流"><a href="#创建自己的可读流" class="header-anchor">#</a> 创建自己的可读流</h2> <p>可读流就是生产数据用来供程序消费的流。</p> <ol><li>生成数据</li> <li>消费数据</li></ol> <p>控制台 process.stdin 也是一个可读流：process.stdin 生产数据的方式是读取用户在控制台的输入。</p> <p>如果我们想自己以某种特定的方式生产数据，交给程序消费，那么改如何开始呢？</p> <p>简单两步即可</p> <ol><li>继承 sream 模块的 Readable 类</li> <li>重写 _read 方法，调用 this.push 将生产的数据放入待读取队列</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Readable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写入数据</span>
inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;hello node&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有数据了</span>
<span class="token comment">// 将这个可读流，导入到可写流 process.stdout。</span>
inStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>先把所有数据都 push 进 inStream，再使用管道导入到可写流 process.stdout 中。</p> <p>这样，当我们用 node 运行文件时，我们可以从 inStream 中读取所有数据，并且打印出来。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Readable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> randomNumber <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 只能 push 字符串或 Buffer，为了方便显示打一个回车</span>
        ctx<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>randomNumber<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        max <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>new stream.Writable([options]) write &lt;Function&gt; 对 stream._write() 方法的实现。</code></p> <ul><li>刚创建出的可读流只是一个空壳，保存着一些初始状态。</li> <li>监听它的 data 事件，将会自动调用该可读流的 resume()方法，使流切换至流动模式。</li> <li>在 resume()方法的内部函数_resume()中，对可读流进行了一次 read(0)调用。</li> <li>read(0)调用的内部，首先检查流是否符合了结束条件，若符合，则结束之。否则调用实例实现的_read(size)方法读取一段预设的警戒线（highWaterMark）大小的数据。</li> <li>在实例实现_read(size)函数时内部调用的 this.push(data)方法里，会先判断的读到的数据是否为结束符，若是，则将流的状态设为结束，然后再一次对可读流调用 read(0)。</li> <li>在可读流的 read()方法内部，通过调用在实例层面实现的read(size)方法，取得了一段（设置的警戒线）大小的数据，但是，你可能会疑惑，这只是读取了一次数据啊，理想情况下，应该是循环调用_read(size)直至取完所有数据才对啊！？其实，这部分的逻辑存在于我们实现_read(size)方法时，在其内部调用的 this.push(data)方法中，在最后其会调用私有方法 maybeReadMore()，再次触发 read(0)，接着在 read(0)函数的代码中再次判断可读流是否能够结束,否则再进行一次_read(size)读取。</li></ul> <p>通过 this.push 向缓冲区推送数据,push 的内容只能是字符串或者 Buffer，不能是数字,push 方法有第二个参数 encoding，用于第一个参数是字符串时指定 encoding</p> <h2 id="可读流的两种状态"><a href="#可读流的两种状态" class="header-anchor">#</a> 可读流的两种状态</h2> <p>流在默认状态下是处于暂停模式的，也就是需要程序显式的调用 read() 方法，可我们的例子中并没有调用就可以得到数据，因为我们的流通过 pipe() 方法切换成了流动模式，这样我们的 _read() 方法会自动被反复调用，直到数据读取完毕，所以我们每次 _read() 方法里面只需要读取一次数据即可。</p> <p>read(0)函数的代码中再次判断可读流是否能够结束,否则再进行一次_read(size)读取。</p> <p>流从默认的暂停模式切换到流动模式可以使用以下几种方式：</p> <ul><li>通过添加 data 事件监听器来启动数据监听</li> <li>调用 resume() 方法启动数据流</li> <li>调用 pipe() 方法将数据转接到另一个 可写流</li></ul> <p>从流动模式切换为暂停模式又两种方法：</p> <ul><li>在流没有 pipe() 时，调用 pause() 方法可以将流暂停</li> <li>pipe() 时，需要移除所有 data 事件的监听，再调用 unpipe() 方法</li></ul> <h2 id="read-size"><a href="#read-size" class="header-anchor">#</a> read(size)</h2> <p>流在暂停模式下需要程序显式调用 read() 方法才能得到数据。read() 方法会从内部缓冲区中拉取并返回若干数据，当没有更多可用数据时，会返回null。</p> <p>使用 read() 方法读取数据时，如果传入了 size 参数，那么它会返回指定字节的数据；当指定的size字节不可用时，则返回null。如果没有指定size参数，那么会返回内部缓冲区中的所有数据。</p> <p>现在有一个矛盾了，在流动模式下流生产出了数据，然后触发 data 事件通知给程序，这样很方便。在暂停模式下需要程序去读取，那么就有一种可能是读取的时候还没生产好（缓存区没有数据），如果我们才用轮询的方式未免效率有些低。</p> <p>NodeJS 为我们提供了一个 readable 的事件，事件在可读流准备好数据的时候触发，也就是先监听这个事件，收到通知有数据了我们再去读取就好了.</p> <p>read 从内部缓冲拉取并返回数据。 如果没有可读的数据，则返回 null。 默认情况下， readable.read() 返回的数据是 Buffer 对象，除非使用 readable.setEncoding() 指定字符编码或流处于对象模式。</p> <h2 id="数据会不会漏掉"><a href="#数据会不会漏掉" class="header-anchor">#</a> 数据会不会漏掉</h2> <p>开始使用流动模式的时候我经常会担心一个问题，上面代码中可读流在创建好的时候就生产数据了，那么会不会在我们绑定 readable 事件之前就生产了某些数据，触发了 readable 事件，我们还没有绑定，这样不是极端情况下会造成开头数据的丢失嘛</p> <p>可事实并不会，按照 NodeJS event loop 我们创建流和调用事件监听在一个事件队列里面，儿生产数据由于涉及到异步操作，已经处于了下一个事件队列，我们监听事件再慢也会比数据生产块，数据不会丢失。</p> <h2 id="关于-push-的数据大小"><a href="#关于-push-的数据大小" class="header-anchor">#</a> 关于 push 的数据大小</h2> <p>每次生产的数据大小，其实是每次被读取的数据的大小，因为生产到缓存中的数据，会立即被消费。</p> <p>所以 push 的大小尽量细分。而且要在消费时再 push，即写在_write里面</p> <h2 id="可写流工作流程"><a href="#可写流工作流程" class="header-anchor">#</a> 可写流工作流程</h2> <p><img src="/node_study/assets/img/download.0dbc5909.png" alt=""></p> <ul><li>可读流也有缓存区，等待数据写入底层后，推出数据</li></ul> <h2 id="双工流"><a href="#双工流" class="header-anchor">#</a> 双工流</h2> <p>同时实现write和read即可</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Duplex <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Duplex<span class="token punctuation">;</span>

<span class="token keyword">const</span> myDuplex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Duplex</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="转换流"><a href="#转换流" class="header-anchor">#</a> 转换流</h2> <p>转换流是一种双工流，它会对输入做些计算然后输出。 例如 zlib 流和 crypto 流会压缩、加密或解密数据。</p> <p>在Duplex流中，可读流中的数据和可写流中的数据是分开的。</p> <p>而Transform流是一种特殊的Duplex流，它继承自Duplex流，其可写端的数据经变换后会自动添加到可读端，转换流（Transform）是一种 Duplex 流，但它的输出与输入是相关联的。</p> <p>所以当我们自定义 Transform 流时，只需要：</p> <ol><li>继承 Transform 类</li> <li>实现 _transform() 方法</li> <li>实现_flush() 方法（可以不实现）</li></ol> <p>_transform(chunk, encoding, callback) 方法用来接收数据，并产生输出，参数我们已经很熟悉了，和 Writable 一样， chunk 默认是 Buffer，除非 decodeStrings 被设置为 false。
在 _transform() 方法内部可以调用 this.push(data) 生产数据，交给可写流，也可以不调用，意味着输入不会产生输出。</p> <p>当数据处理完了必须调用 callback(err, data) ，第一个参数用于传递错误信息，第二个参数可以省略，如果被传入了，效果和 this.push(data) 一样</p> <p>Transform 流有两个常用的事件:</p> <ol><li>来自 Writable 的 finish</li> <li>来自 Readable 的 end</li></ol> <p>当调用 transform.end() 并且数据被 _transform() 处理完后会触发 finish，调用_flush后，所有的数据输出完毕，触发end事件。</p> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h2> <p>我们经常看到的webpack loader其实就是转化流加pipe的链式调用。loader之间数据的传递。</p> <h2 id="缓冲"><a href="#缓冲" class="header-anchor">#</a> 缓冲</h2> <p>流中一个相当重要的概念，无论读写流都是通过缓冲来实现的。
可写流和可读流都会在一个内部的缓冲器中存储数据，可以分别使用的 writable.writableBuffer 或 readable.readableBuffer 来获取，可缓冲的数据的数量取决于传入流构造函数的 highWaterMark 选项，默认情况下highWaterMark 64*1024个字节
读写的过程都是将数据读取写入缓冲，然后在将数据读出或者写入文件。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/node_study/eleventh/" class="prev">
        第九章-Node.js DBMS
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/node_study/assets/js/app.7ec7703d.js" defer></script><script src="/node_study/assets/js/2.0b30fde4.js" defer></script><script src="/node_study/assets/js/6.42114519.js" defer></script>
  </body>
</html>
