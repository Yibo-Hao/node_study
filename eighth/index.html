<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第六章-Node.js HTTP模块 + path 的两个API | node学习</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/node_study/assets/css/0.styles.d8fcd520.css" as="style"><link rel="preload" href="/node_study/assets/js/app.7ec7703d.js" as="script"><link rel="preload" href="/node_study/assets/js/2.0b30fde4.js" as="script"><link rel="preload" href="/node_study/assets/js/5.dc83de53.js" as="script"><link rel="prefetch" href="/node_study/assets/js/10.41c910e2.js"><link rel="prefetch" href="/node_study/assets/js/11.877f2538.js"><link rel="prefetch" href="/node_study/assets/js/12.1dea1fe9.js"><link rel="prefetch" href="/node_study/assets/js/13.03707fd2.js"><link rel="prefetch" href="/node_study/assets/js/14.74174926.js"><link rel="prefetch" href="/node_study/assets/js/15.240f734b.js"><link rel="prefetch" href="/node_study/assets/js/16.3d8565bd.js"><link rel="prefetch" href="/node_study/assets/js/17.7817c8e9.js"><link rel="prefetch" href="/node_study/assets/js/3.e87d396a.js"><link rel="prefetch" href="/node_study/assets/js/4.aa1c6637.js"><link rel="prefetch" href="/node_study/assets/js/6.42114519.js"><link rel="prefetch" href="/node_study/assets/js/7.5229d775.js"><link rel="prefetch" href="/node_study/assets/js/8.07f7fc74.js"><link rel="prefetch" href="/node_study/assets/js/9.de1235a9.js">
    <link rel="stylesheet" href="/node_study/assets/css/0.styles.d8fcd520.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/node_study/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/node_study/first/" class="sidebar-link">第一章-Node.js技术架构</a></li><li><a href="/node_study/second/" class="sidebar-link">第二章-Node.js文件模块（基础知识）</a></li><li><a href="/node_study/third/" class="sidebar-link">第二章-Node.js文件模块（Node.js）</a></li><li><a href="/node_study/four/" class="sidebar-link">第三章-package</a></li><li><a href="/node_study/fifth/" class="sidebar-link">第三章-Node.js命令行工具（命令行开发）</a></li><li><a href="/node_study/sixth/" class="sidebar-link">第四章-Node.js,jest 测试</a></li><li><a href="/node_study/seventh/" class="sidebar-link">第五章-Node.js,认识V8引擎（基础知识扩展）</a></li><li><a href="/node_study/eighth/" aria-current="page" class="active sidebar-link">第六章-Node.js,HTTP模块 + path 的两个API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node_study/eighth/#i-o多路复用-又被称为-事件驱动" class="sidebar-link">I/O多路复用(又被称为“事件驱动”)</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#hello-world" class="sidebar-link">hello world</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#http-server的事件" class="sidebar-link">http.Server的事件</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#incomingmessage-和-serverresponse" class="sidebar-link">IncomingMessage 和 ServerResponse</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#tcp与http" class="sidebar-link">TCP与HTTP</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#http报文" class="sidebar-link">HTTP报文</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#请求行" class="sidebar-link">请求行</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#请求头" class="sidebar-link">请求头</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#请求体" class="sidebar-link">请求体</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#响应行" class="sidebar-link">响应行</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#响应头" class="sidebar-link">响应头</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#响应体" class="sidebar-link">响应体</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#关于method" class="sidebar-link">关于method</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#关于响应实体和content-type" class="sidebar-link">关于响应实体和Content-Type</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#用tcp实现一个简单的http服务器" class="sidebar-link">用tcp实现一个简单的http服务器</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#node-作为客户端" class="sidebar-link">node 作为客户端</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#静态服务器" class="sidebar-link">静态服务器</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#path-resolve-paths" class="sidebar-link">path.resolve([...paths])</a></li><li class="sidebar-sub-header"><a href="/node_study/eighth/#path-join-paths" class="sidebar-link">path.join([...paths])</a></li></ul></li><li><a href="/node_study/ninth/" class="sidebar-link">第七章-Node.js 全局变量</a></li><li><a href="/node_study/tenth/" class="sidebar-link">第八章-Node.js 模块实现 + JS对象小知识点</a></li><li><a href="/node_study/eleventh/" class="sidebar-link">第九章-Node.js DBMS</a></li><li><a href="/node_study/twelve/" class="sidebar-link">第十章-Node.js 流</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第六章-node-js-http模块-path-的两个api"><a href="#第六章-node-js-http模块-path-的两个api" class="header-anchor">#</a> 第六章-Node.js HTTP模块 + path 的两个API</h1> <h2 id="i-o多路复用-又被称为-事件驱动"><a href="#i-o多路复用-又被称为-事件驱动" class="header-anchor">#</a> I/O多路复用(又被称为“事件驱动”)</h2> <p>Node.js采用的网络请求处理模型是IO多路复用。它与传统的主从多线程并发模型是有区别的：只使用有限的线程数（1个），所以占用系统资源很少；操作系统级的异步IO支持，可以减少用户态/内核态切换，并且本身性能更高（因为直接与网卡驱动交互）；JavaScript天生具有保护程序执行现场的能力（闭包），传统模型要么依赖应用程序自己保存现场，或者依赖线程切换时自动完成。当然，并不能说IO多路复用就是最好的并发模型，关键还是看应用场景。</p> <h2 id="hello-world"><a href="#hello-world" class="header-anchor">#</a> hello world</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> serve <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
serve<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span>response</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;hi world&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
serve<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>
</code></pre></div><p>Node.js 把许多细节都已在源码中封装好了，主要代码在 lib/http*.js 这些文件中</p> <p>在 Node.js 中，若要收到一个 HTTP 请求，首先需要创建一个 http.Server 类的实例，然后监听它的 request 事件。由于 HTTP 协议属于应用层，在下层的传输层通常使用的是 TCP 协议，所以 net.Server 类正是 http.Server 类的父类。</p> <h2 id="http-server的事件"><a href="#http-server的事件" class="header-anchor">#</a> http.Server的事件</h2> <p>http.Server 是一个基于事件的服务器，继承自 EventEmitter。通过http.createServer()创建实例，'request' 事件 每次请求的时候都会触发。http服务是以request为单位进行服务的。,http.Server 提供的事件如下所示：</p> <ul><li>request：当客户端请求到来时，该事件被触发，提供两个参数req和res，表示请求和响应信息，是最常用的事件。</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code>serve<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token operator">:</span> IncomingMessage<span class="token punctuation">,</span>response<span class="token operator">:</span> ServerResponse</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;hi world&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>connection：当TCP连接建立时，该事件被触发，提供一个参数socket，是net.Socket的实例。</li> <li>close：当服务器关闭时，触发事件（注意不是在用户断开连接时）。</li></ul> <h2 id="incomingmessage-和-serverresponse"><a href="#incomingmessage-和-serverresponse" class="header-anchor">#</a> IncomingMessage 和 ServerResponse</h2> <p>这两个类不是由使用者创建，而是由 http.Server 创建作为 request 和 response 的参数。http服务是以request为单位进行服务的。http.IncomingMessage 对象,它可用于访问<strong>本次</strong>，请求的请求方法、消息头、以及数据(图中将，请求头与数据拆分开)。http.ServerResponse 对象,服务端通过http.ServerResponse 实例，来给客户端（数据请求方）返回<strong>本次</strong>数据。包括响应头，响应体(内部通过socket来发送信息)。</p> <p>它可用于访问本次，请求的请求方法、消息头、以及数据，它继承自 stream.Readable 类。</p> <p>由于tcp分组发送，获取请求<strong>体</strong>，请求头和请求行需要request的特定属性来获得</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//在node中获取请求体</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> serve <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
serve<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span>response</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    
    request<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    request<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        Buffer<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
serve<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>
</code></pre></div><p>ServerResponse目的是为了修改返回的信息，以及结束响应，继承自 Stream，此对象由 HTTP 服务器在内部创建，而不是由用户创建。 它会作为第二个参数传给 'request' 事件。</p> <ul><li>response.statusCode，默认值: 200。</li> <li>response.setHeader(name, value)，为隐式响应头设置单个响应头的值。如果此响应头已存在于待发送的响应头中，则其值将被替换。</li> <li>response.end()，可以设置响应体，如果指定了 data，则相当于调用 response.write(data, encoding) 之后再调用 response.end(callback)。</li> <li>response.write(chunk[, encoding][, callback])，设置响应体</li> <li>默认情况下响应体为字符串，但是我们可以设置Content-Type来返回不同的东西</li></ul> <p>第一次调用 response.write() 时，它会将缓冲的响应头信息和主体的第一个数据块发送给客户端。 第二次调用 response.write() 时，Node.js 假定数据将被流式传输，并分别发送新数据。 也就是说，响应被缓冲到主体的第一个数据块。</p> <h2 id="tcp与http"><a href="#tcp与http" class="header-anchor">#</a> TCP与HTTP</h2> <p>首先，HTTP 是基于 TCP 协议的，只有当tcp连接顺利建立时，浏览器客户端才能向服务器发送http请求。（详见TCP三次握手）。http服务器是继承自tcp服务器， http协议是应用层协议 是基于TCP的 对请求和响应进行了包装</p> <p>当TCP 让让一台pc端对端的连接上另一台pc后，两台机器之间可以互通数据，但这个数据并没有经过什么额外的加工，是纯粹的数据，即用户输入什么数据，服务器就会拿到什么数据。</p> <p>而 HTTP 有些许不一样， 一个http请求会将用户的输入经过浏览器包装后再发送给服务端，而包装后的数据即是我们说的 http请求报文。对应的，服务器要向浏览器回复响应，也需要经过一层包装，包装成 http响应报文再响应给客户端。</p> <p>从传输层面上来讲，http仅仅是tcp的一项子集，一种再封装。</p> <h2 id="http报文"><a href="#http报文" class="header-anchor">#</a> HTTP报文</h2> <p>主要分文两大类，请求报文 和 响应报文，请求报文和响应报文又都分为行、 头 和 体 三部分，并且头和体这两部分之间有 空行 隔开。学会了报文就学会了浏览器如何封装的就学会了HTTP。</p> <p><img src="/node_study/assets/img/download1.f8efa07d.png" alt=""> <img src="/node_study/assets/img/download.d107d8e9.png" alt=""></p> <h2 id="请求行"><a href="#请求行" class="header-anchor">#</a> 请求行</h2> <p>请求行：请求行分为以下三部分，每个部分之间用空格隔开</p> <ul><li>method： 主要是用来标识是要传数据还是获取数据</li> <li>path： url地址</li> <li>protocol http的协议版本号</li></ul> <h2 id="请求头"><a href="#请求头" class="header-anchor">#</a> 请求头</h2> <p>请求头和请求行不一样，它是多行的，每一行都是一组键值对，键和值之间用:和空格隔开。</p> <ul><li>请求首部: Host:xxx.com</li> <li>通用首部: 请求和响应都有的，比如 Connection:keep-alive</li> <li>实体首部： 以 Content-开头的</li> <li>其它</li></ul> <h2 id="请求体"><a href="#请求体" class="header-anchor">#</a> 请求体</h2> <p>正经的，用户想要传给服务器的数据</p> <h2 id="响应行"><a href="#响应行" class="header-anchor">#</a> 响应行</h2> <ul><li>protocol http协议版本号</li> <li>statusCode 状态码</li> <li>statusCode-reason 原因短语，状态码的解释</li></ul> <h2 id="响应头"><a href="#响应头" class="header-anchor">#</a> 响应头</h2> <p>同请求头</p> <h2 id="响应体"><a href="#响应体" class="header-anchor">#</a> 响应体</h2> <p>同请求体</p> <h2 id="关于method"><a href="#关于method" class="header-anchor">#</a> 关于method</h2> <ul><li>GET 获取资源</li> <li>POST 想服务器端发送数据，传输实体主体</li> <li>PUT 传输文件 ， RESTful中是更新修改操作</li> <li>HEAD 获取报文首部</li> <li>DELETE 删除文件</li> <li>OPTIONS 询问支持的方法 ，试探方法，比如跨域，会先询问服务端能否跨域</li> <li>TRACE 追踪路径</li></ul> <h2 id="关于响应实体和content-type"><a href="#关于响应实体和content-type" class="header-anchor">#</a> 关于响应实体和Content-Type</h2> <p>客户端发送请求和服务端回以响应时都需要设置这个Content-Type头，
对于服务端来说，它需要拿这个头解析客户端发送过来的实体数据，（纵然不少情况下，请求都没有实体部分，比如get请求）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> buffers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    buffers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> content <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>buffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>contentType <span class="token operator">===</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>contentType <span class="token operator">===</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> queryString <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queryString<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>实际情况下，如果有请求体（实体数据），可能会很复杂。（前面的请求体部分）</p> <p>并且服务端响应客户端数据时也需要发给它这么一个头以便客户端解析数据，而这个Content-Type往往和要返回给客户端的资源文件的后缀名是相关联的，So我们一般使用一个npm包帮我们进行转换</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">...</span>
<span class="token keyword">let</span> mime <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span>mime<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">';charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="用tcp实现一个简单的http服务器"><a href="#用tcp实现一个简单的http服务器" class="header-anchor">#</a> 用tcp实现一个简单的http服务器</h2> <p>http服务器相较于tcp服务器其实就多做了一件事，即解析请求头，剩下的请求体部分该on data还是一样on data监听即可。</p> <p>但需要注意的是，data，即请求体是什么时候 发射 的呢？嗯，是在分离出请求头并解析完毕请求头后发射的。</p> <p><img src="/node_study/assets/img/download.d107d8e9.png" alt=""></p> <p>这里分离请求报文是指将 请求体 与其它两部分（请求行，请求头）分成两块，怎么分？嗯，前面说过，请求体和请求头之间有一行空行作为分隔，即 \r\n\r\n 或则说 0x0d 0x0a 0x0d 0x0a。原理是这样的</p> <p>虽然http不想tcp一样可以一直保持长连接，但我们说过它毕竟是基于tcp的，所以也具有保持连接的能力。
在响应头中往往会包含 Connection:keep-alive 字样的字段，就是让浏览器保持连接不要中断，即使接受完响应信息，这个连接一般也能保持一定的时间（大概，嗯，2min？）</p> <p>http发送请求时如果包含多个，可以不用等待就能直接发送下一个请求。</p> <p>Chrome 并发量约为6个，Firefox 4个。</p> <h2 id="node-作为客户端"><a href="#node-作为客户端" class="header-anchor">#</a> node 作为客户端</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
   host<span class="token operator">:</span><span class="token string">'localhost'</span>
  <span class="token punctuation">,</span>port<span class="token operator">:</span><span class="token number">8080</span>
  <span class="token punctuation">,</span>method<span class="token operator">:</span><span class="token string">'POST'</span>
  <span class="token punctuation">,</span>headers<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token string">'Content-Type'</span><span class="token operator">:</span><span class="token string">'application/x-www-form-urlencoded'</span>
<span class="token comment">//      ,'Content-Length':15 //一般来说这个数值会自动计算</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> req <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
req<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'id=999'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 只有调用end才会真正向服务器发送请求</span>
req<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当客户端收到服务器响应的时候触发</span>
req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'response'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//只有一个参数</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>statusCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="静态服务器"><a href="#静态服务器" class="header-anchor">#</a> 静态服务器</h2> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>IncomingMessage<span class="token punctuation">,</span>ServerResponse<span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&quot;url&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> publicDir <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">&quot;public&quot;</span><span class="token punctuation">)</span> <span class="token comment">//得到我们选择的根目录的绝对路径</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token operator">:</span> <span class="token keyword">typeof</span> IncomingMessage<span class="token punctuation">,</span>res<span class="token operator">:</span> <span class="token keyword">typeof</span> ServerResponse</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>url<span class="token operator">:</span> path<span class="token punctuation">}</span> <span class="token operator">=</span> request
    <span class="token keyword">const</span> <span class="token punctuation">{</span>pathname<span class="token punctuation">}</span> <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>
    <span class="token keyword">const</span> filename <span class="token operator">=</span> pathname<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">//根据url中的path（我们选择的根目录）来获取目标文件的绝对路径</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>publicDir<span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">.</span>errno<span class="token operator">===</span><span class="token operator">-</span><span class="token number">4058</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span>
                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">500</span>
                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>请求头中的url指的是根目录下的路径</li> <li>我们得到选择的根目录的绝对路径，就可以把两者结合起来来读取任意被请求的文件</li></ul> <h2 id="path-resolve-paths"><a href="#path-resolve-paths" class="header-anchor">#</a> path.resolve([...paths])</h2> <p>path.resolve就相当于是shell下面的cd操作，从左到右运行一遍cd path命令，最终获取的绝对路径/文件名，这个接口所返回的结果了。但是resolve操作和cd操作还是有区别的，resolve的路径可以没有，而且最后进入的可以是文件。
<code>const publicDir = p.resolve(__dirname,&quot;public&quot;)</code></p> <h2 id="path-join-paths"><a href="#path-join-paths" class="header-anchor">#</a> path.join([...paths])</h2> <ul><li>传入的参数是字符串的路径片段，可以是一个，也可以是多个</li> <li>返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是/，Windows系统是\，那么你在两个系统下看到的返回结果就不一样。</li> <li>如果返回的路径字符串长度为零，那么他会返回一个.，代表当前的文件夹。</li> <li>如果传入的参数中有不是字符串的，那就直接会报错</li> <li>单纯地用&quot;&quot;或&quot;/&quot;拼接字符串</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/node_study/seventh/" class="prev">
        第五章-Node.js,认识V8引擎（基础知识扩展）
      </a></span> <span class="next"><a href="/node_study/ninth/">
        第七章-Node.js 全局变量
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/node_study/assets/js/app.7ec7703d.js" defer></script><script src="/node_study/assets/js/2.0b30fde4.js" defer></script><script src="/node_study/assets/js/5.dc83de53.js" defer></script>
  </body>
</html>
