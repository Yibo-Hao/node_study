<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第二章-Node.js文件模块（基础知识） | node学习</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/node_study/assets/css/0.styles.d8fcd520.css" as="style"><link rel="preload" href="/node_study/assets/js/app.7ec7703d.js" as="script"><link rel="preload" href="/node_study/assets/js/2.0b30fde4.js" as="script"><link rel="preload" href="/node_study/assets/js/14.74174926.js" as="script"><link rel="prefetch" href="/node_study/assets/js/10.41c910e2.js"><link rel="prefetch" href="/node_study/assets/js/11.877f2538.js"><link rel="prefetch" href="/node_study/assets/js/12.1dea1fe9.js"><link rel="prefetch" href="/node_study/assets/js/13.03707fd2.js"><link rel="prefetch" href="/node_study/assets/js/15.240f734b.js"><link rel="prefetch" href="/node_study/assets/js/16.3d8565bd.js"><link rel="prefetch" href="/node_study/assets/js/17.7817c8e9.js"><link rel="prefetch" href="/node_study/assets/js/3.e87d396a.js"><link rel="prefetch" href="/node_study/assets/js/4.aa1c6637.js"><link rel="prefetch" href="/node_study/assets/js/5.dc83de53.js"><link rel="prefetch" href="/node_study/assets/js/6.42114519.js"><link rel="prefetch" href="/node_study/assets/js/7.5229d775.js"><link rel="prefetch" href="/node_study/assets/js/8.07f7fc74.js"><link rel="prefetch" href="/node_study/assets/js/9.de1235a9.js">
    <link rel="stylesheet" href="/node_study/assets/css/0.styles.d8fcd520.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/node_study/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/node_study/first/" class="sidebar-link">第一章-Node.js技术架构</a></li><li><a href="/node_study/second/" aria-current="page" class="active sidebar-link">第二章-Node.js文件模块（基础知识）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node_study/second/#文件系统" class="sidebar-link">文件系统</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#node-js的fs模块" class="sidebar-link">Node.js的fs模块</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#js如何通过，libuv如何读写文件" class="sidebar-link">js如何通过，libuv如何读写文件</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#cache和buffer是什么" class="sidebar-link">Cache和Buffer是什么</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#权限位-mode" class="sidebar-link">权限位 mode</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#文件系统标志-flag" class="sidebar-link">文件系统标志 flag</a></li><li class="sidebar-sub-header"><a href="/node_study/second/#文件描述符-fs" class="sidebar-link">文件描述符 fs</a></li></ul></li><li><a href="/node_study/third/" class="sidebar-link">第二章-Node.js文件模块（Node.js）</a></li><li><a href="/node_study/four/" class="sidebar-link">第三章-package</a></li><li><a href="/node_study/fifth/" class="sidebar-link">第三章-Node.js命令行工具（命令行开发）</a></li><li><a href="/node_study/sixth/" class="sidebar-link">第四章-Node.js,jest 测试</a></li><li><a href="/node_study/seventh/" class="sidebar-link">第五章-Node.js,认识V8引擎（基础知识扩展）</a></li><li><a href="/node_study/eighth/" class="sidebar-link">第六章-Node.js,HTTP模块 + path 的两个API</a></li><li><a href="/node_study/ninth/" class="sidebar-link">第七章-Node.js 全局变量</a></li><li><a href="/node_study/tenth/" class="sidebar-link">第八章-Node.js 模块实现 + JS对象小知识点</a></li><li><a href="/node_study/eleventh/" class="sidebar-link">第九章-Node.js DBMS</a></li><li><a href="/node_study/twelve/" class="sidebar-link">第十章-Node.js 流</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第二章-node-js文件模块（基础知识）"><a href="#第二章-node-js文件模块（基础知识）" class="header-anchor">#</a> 第二章-Node.js文件模块（基础知识）</h1> <h2 id="文件系统"><a href="#文件系统" class="header-anchor">#</a> 文件系统</h2> <p>文件系统并不是由 js 或者 Node.js 实现的，而是由我们的操作系统，其中包含了如何分配存储，如何读取存储，如何实现文件系统和操作系统的协作交互。一句话总结一下文件系统其实就是：对磁盘设备的抽象，屏蔽了有关如何存储，操作等细节。</p> <p>实际上，webpack 就是 node.js 对文件的操作。</p> <h2 id="node-js的fs模块"><a href="#node-js的fs模块" class="header-anchor">#</a> Node.js的fs模块</h2> <p>实际上，大多数语言都已经实现了文件的读写，具体的做法就是添加抽象层，对于Node.js而言，我用以下简单的图示表示。</p> <p>node提供了对V8和libuv的封装，所以我们在 node 中使用 js 时：</p> <div class="language- extra-class"><pre class="language-text"><code>|----|
|node|
|----|
 |
 |    读取js
 V
|----|
| V8 |
|----|
 |
 |    c++调用lbuv
 V
|------|
|libUV |---&gt;调用系统API,读取文件
|------|
</code></pre></div><p>事件循环这个模型的最大缺点就是，一个实例，单线程，如果有任何阻塞发生（包括CPU计算卡顿）都会摧毁这个模型，所以，有且只有一个解：所有的IO都是，异步非阻塞IO。</p> <p>线程池(Thread pool）模型，简单来说就是程序跑起来前，提前创建一个有多个线程的池子，IO消息来临时，塞进一个队列中，这些线程读取队列中的IO消息进行IO，IO完毕以后，通知主线程，触发回掉函数。</p> <p>对于libuv来说，采用的就是线程池模型。（你没看错，虽然node.js是单线程的，但是也仅仅是主线程单线程，其底下是多线程的一个架构）。</p> <h2 id="js如何通过，libuv如何读写文件"><a href="#js如何通过，libuv如何读写文件" class="header-anchor">#</a> js如何通过，libuv如何读写文件</h2> <ol><li>node.js启动，包括底层的v8、libuv</li> <li>用户写 js 代码调用 fs.read（）函数</li> <li>fs.read（）之下，提交一个文件读取request（请求），立即返回，跑接下去的代码。</li> <li>nodejs拿到这个request，传递给V8，v8解析以后，调用libuv的接口，塞入libuv的线程池队列</li> <li>libuv的线程池队列拿到请求，选择一个线程，执行io操作，此时，读取io的线程卡住，但是整个系统依旧在跑</li> <li>io 结束，执行 io 的线程将结果和完成标识符（done）</li> <li>底层libuv调用 uv__fs_done 函数，这个是异步文件io结束后的回调函数。在uv__fs_done里面会回调上层C++模块的callback函数，这个callback函数就是我们用户指定的js层函数了。</li></ol> <ul><li>要实现js文件io，那必须要使得js能够调用系统API，也就是c++那层。这一层工作，由V8执行。</li> <li>nodejs中，js文件io的事情，实际上是右libuv中的file/io来进行执行的。</li></ul> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <ol><li>事件循环本身就在libuv里。</li> <li>在第六步io结束的时候，io线程设置了标识位，表示完成。然后线程归还线程库，等待继续调用。</li> <li>libuv有一条线程是io观察者，这个io观察者会不断的检查这个标识位。当这个标识位为done的时候，io观察者就会触发回调。</li> <li>io观察者将完成的事件放到自身的队列中，当成已经完成的对象，等待事件循环的处理</li> <li>然后回调，上述整个过程叫做:event loop。</li></ol> <p>这个回答了我的一个疑问，event loop既然是新的线程，怎么知道我的异步IO结束了。</p> <h2 id="cache和buffer是什么"><a href="#cache和buffer是什么" class="header-anchor">#</a> Cache和Buffer是什么</h2> <ul><li>Buffer的核心作用是用来缓冲，缓和冲击。比如你每秒要写100次硬盘，对系统冲击很大，浪费了大量时间在忙着处理开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲击就很小，写入效率高了，日子过得爽了。极大缓和了冲击。</li> <li>Cache的核心作用是加快取用的速度。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个好拿的地方存着，下次不用再算了。加快了数据取用的速度。</li> <li>所以，如果你注意关心过存储系统的话，你会发现硬盘的读写缓冲/缓存名称是不一样的，叫write-buffer和read-cache。很明显地说出了两者的区别。</li> <li>宏观上说两者可能是混用的，你说拿cache做buffer用行不行？当然行，只要能控制cache淘汰逻辑就没有任何问题。那么拿buffer做cache用呢？貌似在很特殊的情况下，能确定访问顺序的时候，也是可以的。简单想一下就明白——buffer根据定义，需要随机存储吗？一般是不需要的。但cache一定要。所以大多数时候用cache代替buffer可以，反之就比较局限。这也是技术上说cache和buffer的关键区别。</li> <li>补充1：不要误解Buffer就是用来写的，Cache就是用来读的。读可以用Buffer吗？当然可以，比如你想一批一批地处理读取而非有啥处理啥的时候，就可以用读buffer。写当然也可以用cache，比如你的写入有很高的随机性的时候。具体什么场景用Buffer什么场景用Cache要根据场景的具体需要决定。</li> <li>补充2：不要误解Cache或Buffer就一定是内存或者存在什么高速媒介上的东西。只要相对高速即可。我完全可以在硬盘上存Cache，比如有些游戏会在运行时建立预编译的shader（暴露年龄），这本质上就是一种cache，它存在速度缓慢的硬盘上，因为读硬盘依旧比重新编译要快。Buffer也同理，例如NTFS文件系统自己就有Logging Buffer，这个甚至明确拒绝放在任何易失缓存里。</li> <li>Cache和Buffer最大的区别在于，Buffer进多少数据就要出多少数据，Cache则进出不对称的，越不对称越好。</li> <li>read-cache和write-buffer</li></ul> <h3 id="随机存取和串行访问"><a href="#随机存取和串行访问" class="header-anchor">#</a> 随机存取和串行访问</h3> <p>随机强调的是存取数据所花的时间与目标数据所在的物理位置无关。这是由RAM的结构决定的，RAM使用存储阵列来存储数据，只要给出行地址和列地址，就能确定目标数据，这一过程和目标数据所处的物理位置无关。</p> <p>与随机存取相对的，是串行访问，指存取数据所花的时间与目标数据所在的物理位置有关。串行访问里面又分为顺序存取和直接存取。顺序存取如磁带，要想访问一个某一存储单元，必须先访问该单元前面的单元，（所以就有了听歌时倒磁带的痛苦经历）。直接存取如磁盘，磁头可以直接定位到目标存储单元，不需访问该单元前面的单元。需要注意的是，即使是直接定位，定位磁头所花的时间也是不同的，比如磁头当前在磁道0，定位到磁道2和磁道10000的时间肯定不同，所以存取数据所花的时间与目标数所在的物理位置仍然有关</p> <p>解释了hash数据结构用空间换时间，以及cache必须要用随机存储</p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。</p> <p>而 buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong>（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）</p> <h2 id="权限位-mode"><a href="#权限位-mode" class="header-anchor">#</a> 权限位 mode</h2> <div class="language- extra-class"><pre class="language-text"><code>drwxr-xr-x 1 koala 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 koala 197121 293 Jun 23 17:44 index.md
</code></pre></div><p>第一位代表是文件还是文件夹，d 开头代表文件夹，- 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。</p> <p>权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行</p> <h2 id="文件系统标志-flag"><a href="#文件系统标志-flag" class="header-anchor">#</a> 文件系统标志 flag</h2> <p>'a': 打开文件用于追加。 如果文件不存在，则创建该文件。</p> <p>'ax': 类似于 'a'，但如果路径存在，则失败。</p> <p>'a+': 打开文件用于读取和追加。 如果文件不存在，则创建该文件。</p> <p>'ax+': 类似于 'a+'，但如果路径存在，则失败。</p> <p>'as': 打开文件用于追加（在同步模式中）。 如果文件不存在，则创建该文件。</p> <p>'as+': 打开文件用于读取和追加（在同步模式中）。 如果文件不存在，则创建该文件。</p> <p>'r': 打开文件用于读取。 如果文件不存在，则会发生异常。</p> <p>'r+': 打开文件用于读取和写入。 如果文件不存在，则会发生异常。</p> <p>'rs+': 打开文件用于读取和写入（在同步模式中）。 指示操作系统绕过本地的文件系统缓存。</p> <p>这对于在 NFS 挂载上打开文件时非常有用，因为它可以跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此不建议使用此标志（除非真的需要）。</p> <p>这不会把 fs.open() 或 fsPromises.open() 变成同步的阻塞调用。 如果需要同步的操作，则应使用 fs.openSync() 之类的。</p> <p>'w': 打开文件用于写入。 如果文件不存在则创建文件，如果文件存在则截断文件。</p> <p>'wx': 类似于 'w'，但如果路径存在，则失败。</p> <p>'w+': 打开文件用于读取和写入。 如果文件不存在则创建文件，如果文件存在则截断文件。</p> <p>'wx+': 类似于 'w+'，但如果路径存在，则失败。</p> <h2 id="文件描述符-fs"><a href="#文件描述符-fs" class="header-anchor">#</a> 文件描述符 fs</h2> <p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</p> <p>在 Node.js 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。</p> <p>node.js中文件描述符体会比较少，我们可以通过linux的几个基本的I/O操作函数来理解什么是文件操作符。文件描述符就是内核为了高效管理<strong>已被打开的文件</strong>所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p> <div class="language-js extra-class"><pre class="language-js"><code>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
    <span class="token comment">// 返回了该文件的fd</span>
    rlen <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span>
    <span class="token comment">// IO操作均需要传入该文件的fd值</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>https://juejin.im/post/5d3f1664e51d4561a34618c1</p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/node_study/first/" class="prev">
        第一章-Node.js技术架构
      </a></span> <span class="next"><a href="/node_study/third/">
        第二章-Node.js文件模块（Node.js）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/node_study/assets/js/app.7ec7703d.js" defer></script><script src="/node_study/assets/js/2.0b30fde4.js" defer></script><script src="/node_study/assets/js/14.74174926.js" defer></script>
  </body>
</html>
